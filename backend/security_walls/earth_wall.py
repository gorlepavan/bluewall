"""
Earth Wall - Data Integrity and Database Security

This module monitors database operations to detect and prevent:
- Unauthorized database changes
- Schema tampering attempts
- Data manipulation attacks
- Unusual database access patterns
- Privilege escalation attempts
- Data exfiltration patterns

The Earth Wall acts as a guardian for data integrity,
ensuring all database operations are legitimate and authorized.
"""

import time
import logging
import hashlib
import json
from typing import Dict, List, Optional, Set, Any
from dataclasses import dataclass
from datetime import datetime, timedelta
from enum import Enum
import re
from collections import defaultdict

logger = logging.getLogger(__name__)

class OperationType(Enum):
    """Types of database operations."""
    SELECT = "SELECT"
    INSERT = "INSERT"
    UPDATE = "UPDATE"
    DELETE = "DELETE"
    CREATE = "CREATE"
    ALTER = "ALTER"
    DROP = "DROP"
    GRANT = "GRANT"
    REVOKE = "REVOKE"
    EXECUTE = "EXECUTE"

class DataSensitivity(Enum):
    """Data sensitivity levels."""
    PUBLIC = "public"
    INTERNAL = "internal"
    CONFIDENTIAL = "confidential"
    RESTRICTED = "restricted"
    CRITICAL = "critical"

@dataclass
class DatabaseOperation:
    """Record of a database operation."""
    timestamp: float
    user_id: str
    username: str
    ip_address: str
    operation_type: OperationType
    table_name: str
    query_hash: str
    affected_rows: int
    execution_time_ms: float
    success: bool
    error_message: Optional[str] = None
    session_id: Optional[str] = None

@dataclass
class SchemaChange:
    """Record of a schema change operation."""
    timestamp: float
    user_id: str
    username: str
    ip_address: str
    change_type: str
    object_name: str
    old_schema: Optional[str] = None
    new_schema: Optional[str] = None
    details: Dict = None
    
    def __post_init__(self):
        if self.details is None:
            self.details = {}

@dataclass
class EarthWallAlert:
    """Alert generated by Earth Wall detection."""
    alert_type: str
    severity: str  # low, medium, high, critical
    identifier: str  # user_id, table_name, or operation_hash
    timestamp: datetime
    details: Dict
    mitigation_action: str
    affected_data: Optional[str] = None

class EarthWall:
    """
    Earth Wall implementation for database security and data integrity.
    
    Features:
    - Database operation monitoring
    - Schema change detection
    - Data sensitivity analysis
    - Privilege escalation detection
    - Unusual access pattern detection
    - Data exfiltration prevention
    """
    
    def __init__(self, config: Optional[Dict] = None):
        """
        Initialize Earth Wall with configuration.
        
        Args:
            config: Configuration dictionary with thresholds and settings
        """
        self.config = config or self._get_default_config()
        
        # Operation tracking
        self.database_operations: List[DatabaseOperation] = []
        self.schema_changes: List[SchemaChange] = []
        
        # User operation patterns
        self.user_operation_patterns: Dict[str, Dict] = defaultdict(dict)
        
        # Table access patterns
        self.table_access_patterns: Dict[str, Dict] = defaultdict(dict)
        
        # Sensitive data definitions
        self.sensitive_tables = self._initialize_sensitive_tables()
        self.sensitive_columns = self._initialize_sensitive_columns()
        
        # Alert storage
        self.alerts: List[EarthWallAlert] = []
        
        # Cleanup timer
        self.last_cleanup = time.time()
        self.cleanup_interval = 300  # 5 minutes
        
        logger.info("Earth Wall initialized with configuration: %s", self.config)
    
    def _get_default_config(self) -> Dict:
        """Get default configuration for Earth Wall."""
        return {
            # Operation monitoring thresholds
            "max_operations_per_user_per_minute": 100,
            "max_operations_per_user_per_hour": 1000,
            "max_operations_per_table_per_minute": 50,
            "max_operations_per_table_per_hour": 500,
            
            # Schema change monitoring
            "allow_schema_changes": False,
            "schema_change_approval_required": True,
            "monitored_schema_objects": ["users", "security_alerts", "events"],
            
            # Data sensitivity thresholds
            "max_sensitive_data_access_per_hour": 10,
            "max_bulk_data_operations": 1000,
            "restricted_operation_types": ["DROP", "ALTER", "GRANT", "REVOKE"],
            
            # Privilege escalation detection
            "monitor_privilege_changes": True,
            "restricted_privileges": ["SUPER", "ALL PRIVILEGES", "CREATE USER"],
            
            # Unusual pattern detection
            "unusual_access_time_threshold": 0.1,  # 10% of normal
            "unusual_operation_time_threshold": 2.0,  # 2x normal
            "geographic_anomaly_detection": True,
            
            # Data exfiltration prevention
            "max_data_export_size": 10000,  # rows
            "monitor_bulk_selects": True,
            "restricted_export_tables": ["users", "security_alerts"],
            
            # Cleanup settings
            "cleanup_interval": 300,  # 5 minutes
            "max_storage_duration": 86400,  # 24 hours
            "max_operations_stored": 10000,
        }
    
    def _initialize_sensitive_tables(self) -> Dict[str, DataSensitivity]:
        """Initialize sensitive table definitions."""
        return {
            "users": DataSensitivity.CRITICAL,
            "security_alerts": DataSensitivity.RESTRICTED,
            "events": DataSensitivity.CONFIDENTIAL,
            "audit_logs": DataSensitivity.RESTRICTED,
            "payment_info": DataSensitivity.CRITICAL,
            "personal_data": DataSensitivity.CONFIDENTIAL,
            "system_config": DataSensitivity.RESTRICTED,
        }
    
    def _initialize_sensitive_columns(self) -> Dict[str, Dict[str, DataSensitivity]]:
        """Initialize sensitive column definitions."""
        return {
            "users": {
                "password_hash": DataSensitivity.CRITICAL,
                "totp_secret": DataSensitivity.CRITICAL,
                "email": DataSensitivity.CONFIDENTIAL,
                "phone": DataSensitivity.CONFIDENTIAL,
            },
            "security_alerts": {
                "details": DataSensitivity.RESTRICTED,
                "mitigation_action": DataSensitivity.RESTRICTED,
            },
            "events": {
                "details": DataSensitivity.CONFIDENTIAL,
                "user_data": DataSensitivity.CONFIDENTIAL,
            }
        }
    
    def monitor_operation(self, operation_data: Dict) -> Optional[EarthWallAlert]:
        """
        Monitor a database operation for security threats.
        
        Args:
            operation_data: Dictionary containing operation information
                - user_id: User performing the operation
                - username: Username of the user
                - ip_address: IP address of the user
                - operation_type: Type of database operation
                - table_name: Table being accessed
                - query: SQL query being executed
                - affected_rows: Number of rows affected
                - execution_time_ms: Execution time in milliseconds
                - success: Whether operation was successful
                - error_message: Error message if failed
                - session_id: Database session ID
        
        Returns:
            EarthWallAlert if threat detected, None otherwise
        """
        try:
            current_time = time.time()
            
            # Extract operation information
            user_id = operation_data.get("user_id")
            username = operation_data.get("username")
            ip_address = operation_data.get("ip_address")
            operation_type = OperationType(operation_data.get("operation_type"))
            table_name = operation_data.get("table_name")
            query = operation_data.get("query", "")
            affected_rows = operation_data.get("affected_rows", 0)
            execution_time_ms = operation_data.get("execution_time_ms", 0)
            success = operation_data.get("success", True)
            error_message = operation_data.get("error_message")
            session_id = operation_data.get("session_id")
            
            if not all([user_id, username, ip_address, table_name]):
                logger.warning("Database operation missing required fields")
                return None
            
            # Create operation record
            query_hash = hashlib.sha256(query.encode()).hexdigest()
            operation = DatabaseOperation(
                timestamp=current_time,
                user_id=user_id,
                username=username,
                ip_address=ip_address,
                operation_type=operation_type,
                table_name=table_name,
                query_hash=query_hash,
                affected_rows=affected_rows,
                execution_time_ms=execution_time_ms,
                success=success,
                error_message=error_message,
                session_id=session_id
            )
            
            # Store the operation
            self.database_operations.append(operation)
            
            # Limit stored operations
            if len(self.database_operations) > self.config["max_operations_stored"]:
                self.database_operations = self.database_operations[-self.config["max_operations_stored"]:]
            
            # Update access patterns
            self._update_access_patterns(operation)
            
            # Run security checks
            alerts = []
            
            # Rate limiting checks
            rate_alert = self._check_operation_rate_limits(user_id, table_name, current_time)
            if rate_alert:
                alerts.append(rate_alert)
            
            # Schema change detection
            if operation_type in [OperationType.CREATE, OperationType.ALTER, OperationType.DROP]:
                schema_alert = self._detect_schema_changes(operation, current_time)
                if schema_alert:
                    alerts.append(schema_alert)
            
            # Privilege escalation detection
            privilege_alert = self._detect_privilege_escalation(operation, current_time)
            if privilege_alert:
                alerts.append(privilege_alert)
            
            # Data sensitivity checks
            sensitivity_alert = self._check_data_sensitivity(operation, current_time)
            if sensitivity_alert:
                alerts.append(sensitivity_alert)
            
            # Unusual pattern detection
            pattern_alert = self._detect_unusual_patterns(operation, current_time)
            if pattern_alert:
                alerts.append(pattern_alert)
            
            # Data exfiltration detection
            exfiltration_alert = self._detect_data_exfiltration(operation, current_time)
            if exfiltration_alert:
                alerts.append(exfiltration_alert)
            
            # Return highest severity alert
            if alerts:
                highest_alert = max(alerts, key=lambda x: self._get_severity_level(x.severity))
                # Broadcast alert via WebSocket
                self._broadcast_earth_wall_alert(highest_alert)
                return highest_alert
            
            # Periodic cleanup
            self._periodic_cleanup(current_time)
            
            return None
            
        except Exception as e:
            logger.error(f"Error monitoring operation in Earth Wall: {str(e)}")
            return None
    
    def _update_access_patterns(self, operation: DatabaseOperation):
        """Update access patterns for users and tables."""
        # User operation patterns
        if operation.user_id not in self.user_operation_patterns:
            self.user_operation_patterns[operation.user_id] = {
                "total_operations": 0,
                "operations_by_type": defaultdict(int),
                "operations_by_table": defaultdict(int),
                "last_operation": 0,
                "first_operation": 0,
                "avg_execution_time": 0,
                "total_execution_time": 0
            }
        
        user_patterns = self.user_operation_patterns[operation.user_id]
        user_patterns["total_operations"] += 1
        user_patterns["operations_by_type"][operation.operation_type.value] += 1
        user_patterns["operations_by_table"][operation.table_name] += 1
        user_patterns["last_operation"] = operation.timestamp
        
        if user_patterns["first_operation"] == 0:
            user_patterns["first_operation"] = operation.timestamp
        
        # Update execution time statistics
        user_patterns["total_execution_time"] += operation.execution_time_ms
        user_patterns["avg_execution_time"] = user_patterns["total_execution_time"] / user_patterns["total_operations"]
        
        # Table access patterns
        if operation.table_name not in self.table_access_patterns:
            self.table_access_patterns[operation.table_name] = {
                "total_operations": 0,
                "operations_by_type": defaultdict(int),
                "operations_by_user": defaultdict(int),
                "last_operation": 0,
                "first_operation": 0,
                "total_affected_rows": 0
            }
        
        table_patterns = self.table_access_patterns[operation.table_name]
        table_patterns["total_operations"] += 1
        table_patterns["operations_by_type"][operation.operation_type.value] += 1
        table_patterns["operations_by_user"][operation.user_id] += 1
        table_patterns["last_operation"] = operation.timestamp
        table_patterns["total_affected_rows"] += operation.affected_rows
        
        if table_patterns["first_operation"] == 0:
            table_patterns["first_operation"] = operation.timestamp
    
    def _check_operation_rate_limits(self, user_id: str, table_name: str, current_time: float) -> Optional[EarthWallAlert]:
        """Check if operation violates rate limiting thresholds."""
        # User rate limiting
        user_patterns = self.user_operation_patterns.get(user_id, {})
        if user_patterns:
            operations_last_minute = self._count_operations_in_window(
                self.database_operations, user_id, current_time, 60
            )
            
            if operations_last_minute > self.config["max_operations_per_user_per_minute"]:
                return EarthWallAlert(
                    alert_type="user_rate_limit_exceeded",
                    severity="medium",
                    identifier=user_id,
                    timestamp=datetime.fromtimestamp(current_time),
                    details={
                        "operations_last_minute": operations_last_minute,
                        "limit": self.config["max_operations_per_user_per_minute"],
                        "table": table_name
                    },
                    mitigation_action="user_throttling"
                )
            
            operations_last_hour = self._count_operations_in_window(
                self.database_operations, user_id, current_time, 3600
            )
            
            if operations_last_hour > self.config["max_operations_per_user_per_hour"]:
                return EarthWallAlert(
                    alert_type="user_rate_limit_exceeded",
                    severity="high",
                    identifier=user_id,
                    timestamp=datetime.fromtimestamp(current_time),
                    details={
                        "operations_last_hour": operations_last_hour,
                        "limit": self.config["max_operations_per_user_per_hour"],
                        "table": table_name
                    },
                    mitigation_action="user_blocking"
                )
        
        # Table rate limiting
        table_patterns = self.table_access_patterns.get(table_name, {})
        if table_patterns:
            table_operations_last_minute = self._count_table_operations_in_window(
                self.database_operations, table_name, current_time, 60
            )
            
            if table_operations_last_minute > self.config["max_operations_per_table_per_minute"]:
                return EarthWallAlert(
                    alert_type="table_rate_limit_exceeded",
                    severity="medium",
                    identifier=table_name,
                    timestamp=datetime.fromtimestamp(current_time),
                    details={
                        "operations_last_minute": table_operations_last_minute,
                        "limit": self.config["max_operations_per_table_per_minute"]
                    },
                    mitigation_action="table_throttling"
                )
        
        return None
    
    def _detect_schema_changes(self, operation: DatabaseOperation, current_time: float) -> Optional[EarthWallAlert]:
        """Detect unauthorized schema changes."""
        if not self.config["allow_schema_changes"]:
            return EarthWallAlert(
                alert_type="unauthorized_schema_change",
                severity="critical",
                identifier=f"{operation.user_id}:{operation.table_name}",
                timestamp=datetime.fromtimestamp(current_time),
                details={
                    "operation_type": operation.operation_type.value,
                    "table_name": operation.table_name,
                    "user_id": operation.user_id,
                    "username": operation.username,
                    "reason": "Schema changes not allowed"
                },
                mitigation_action="block_operation"
            )
        
        # Check if schema change approval is required
        if self.config["schema_change_approval_required"]:
            # This would integrate with an approval workflow
            # For now, we'll just log the schema change
            schema_change = SchemaChange(
                timestamp=current_time,
                user_id=operation.user_id,
                username=operation.username,
                ip_address=operation.ip_address,
                change_type=operation.operation_type.value,
                object_name=operation.table_name,
                details={
                    "query_hash": operation.query_hash,
                    "affected_rows": operation.affected_rows
                }
            )
            self.schema_changes.append(schema_change)
            
            return EarthWallAlert(
                alert_type="schema_change_detected",
                severity="medium",
                identifier=f"{operation.user_id}:{operation.table_name}",
                timestamp=datetime.fromtimestamp(current_time),
                details={
                    "operation_type": operation.operation_type.value,
                    "table_name": operation.table_name,
                    "user_id": operation.user_id,
                    "username": operation.username,
                    "approval_required": True
                },
                mitigation_action="require_approval"
            )
        
        return None
    
    def _detect_privilege_escalation(self, operation: DatabaseOperation, current_time: float) -> Optional[EarthWallAlert]:
        """Detect privilege escalation attempts."""
        if not self.config["monitor_privilege_changes"]:
            return None
        
        # Check for restricted operation types
        if operation.operation_type.value in self.config["restricted_operation_types"]:
            return EarthWallAlert(
                alert_type="restricted_operation_attempt",
                severity="high",
                identifier=f"{operation.user_id}:{operation.operation_type.value}",
                timestamp=datetime.fromtimestamp(current_time),
                details={
                    "operation_type": operation.operation_type.value,
                    "table_name": operation.table_name,
                    "user_id": operation.user_id,
                    "username": operation.username,
                    "reason": "Restricted operation type"
                },
                mitigation_action="block_operation"
            )
        
        # Check for privilege-related operations
        if operation.operation_type in [OperationType.GRANT, OperationType.REVOKE]:
            # This would require more sophisticated privilege analysis
            # For now, we'll flag all privilege changes
            return EarthWallAlert(
                alert_type="privilege_change_detected",
                severity="high",
                identifier=f"{operation.user_id}:privilege_change",
                timestamp=datetime.fromtimestamp(current_time),
                details={
                    "operation_type": operation.operation_type.value,
                    "table_name": operation.table_name,
                    "user_id": operation.user_id,
                    "username": operation.username,
                    "details": "Privilege modification detected"
                },
                mitigation_action="review_privileges"
            )
        
        return None
    
    def _check_data_sensitivity(self, operation: DatabaseOperation, current_time: float) -> Optional[EarthWallAlert]:
        """Check data sensitivity and access patterns."""
        table_sensitivity = self.sensitive_tables.get(operation.table_name)
        if not table_sensitivity:
            return None
        
        # Check for bulk operations on sensitive data
        if operation.affected_rows > self.config["max_bulk_data_operations"]:
            return EarthWallAlert(
                alert_type="bulk_sensitive_data_operation",
                severity="high",
                identifier=f"{operation.user_id}:{operation.table_name}",
                timestamp=datetime.fromtimestamp(current_time),
                details={
                    "operation_type": operation.operation_type.value,
                    "table_name": operation.table_name,
                    "affected_rows": operation.affected_rows,
                    "sensitivity": table_sensitivity.value,
                    "limit": self.config["max_bulk_data_operations"]
                },
                mitigation_action="review_operation"
            )
        
        # Check for excessive access to sensitive data
        user_patterns = self.user_operation_patterns.get(operation.user_id, {})
        if user_patterns:
            sensitive_access_last_hour = self._count_sensitive_operations_in_window(
                operation.user_id, current_time, 3600
            )
            
            if sensitive_access_last_hour > self.config["max_sensitive_data_access_per_hour"]:
                return EarthWallAlert(
                    alert_type="excessive_sensitive_data_access",
                    severity="medium",
                    identifier=operation.user_id,
                    timestamp=datetime.fromtimestamp(current_time),
                    details={
                        "sensitive_access_last_hour": sensitive_access_last_hour,
                        "limit": self.config["max_sensitive_data_access_per_hour"],
                        "table": operation.table_name,
                        "sensitivity": table_sensitivity.value
                    },
                    mitigation_action="limit_access"
                )
        
        return None
    
    def _detect_unusual_patterns(self, operation: DatabaseOperation, current_time: float) -> Optional[EarthWallAlert]:
        """Detect unusual access patterns."""
        user_patterns = self.user_operation_patterns.get(operation.user_id, {})
        if not user_patterns or user_patterns["total_operations"] < 10:
            return None  # Need more data for pattern analysis
        
        # Check for unusual execution times
        avg_execution_time = user_patterns["avg_execution_time"]
        if avg_execution_time > 0:
            execution_time_ratio = operation.execution_time_ms / avg_execution_time
            
            if execution_time_ratio > self.config["unusual_operation_time_threshold"]:
                return EarthWallAlert(
                    alert_type="unusual_execution_time",
                    severity="low",
                    identifier=f"{operation.user_id}:execution_time",
                    timestamp=datetime.fromtimestamp(current_time),
                    details={
                        "current_execution_time": operation.execution_time_ms,
                        "average_execution_time": avg_execution_time,
                        "ratio": execution_time_ratio,
                        "threshold": self.config["unusual_operation_time_threshold"]
                    },
                    mitigation_action="monitor_performance"
                )
        
        # Check for unusual access times (if we had time-based patterns)
        # This would require more sophisticated time pattern analysis
        
        return None
    
    def _detect_data_exfiltration(self, operation: DatabaseOperation, current_time: float) -> Optional[EarthWallAlert]:
        """Detect potential data exfiltration attempts."""
        if not self.config["monitor_bulk_selects"]:
            return None
        
        # Check for large SELECT operations
        if (operation.operation_type == OperationType.SELECT and 
            operation.affected_rows > self.config["max_data_export_size"]):
            
            return EarthWallAlert(
                alert_type="large_data_export",
                severity="medium",
                identifier=f"{operation.user_id}:{operation.table_name}",
                timestamp=datetime.fromtimestamp(current_time),
                details={
                    "operation_type": operation.operation_type.value,
                    "table_name": operation.table_name,
                    "affected_rows": operation.affected_rows,
                    "limit": self.config["max_data_export_size"],
                    "pattern": "potential_data_exfiltration"
                },
                mitigation_action="review_export"
            )
        
        # Check for access to restricted export tables
        if (operation.operation_type == OperationType.SELECT and 
            operation.table_name in self.config["restricted_export_tables"]):
            
            return EarthWallAlert(
                alert_type="restricted_table_access",
                severity="high",
                identifier=f"{operation.user_id}:{operation.table_name}",
                timestamp=datetime.fromtimestamp(current_time),
                details={
                    "operation_type": operation.operation_type.value,
                    "table_name": operation.table_name,
                    "user_id": operation.user_id,
                    "username": operation.username,
                    "reason": "Restricted export table"
                },
                mitigation_action="block_access"
            )
        
        return None
    
    def _count_operations_in_window(self, operations: List[DatabaseOperation], user_id: str, 
                                   current_time: float, window_seconds: int) -> int:
        """Count operations by a user within a time window."""
        cutoff_time = current_time - window_seconds
        return sum(1 for op in operations 
                  if op.user_id == user_id and op.timestamp > cutoff_time)
    
    def _count_table_operations_in_window(self, operations: List[DatabaseOperation], table_name: str,
                                         current_time: float, window_seconds: int) -> int:
        """Count operations on a table within a time window."""
        cutoff_time = current_time - window_seconds
        return sum(1 for op in operations 
                  if op.table_name == table_name and op.timestamp > cutoff_time)
    
    def _count_sensitive_operations_in_window(self, user_id: str, current_time: float, 
                                            window_seconds: int) -> int:
        """Count sensitive data operations by a user within a time window."""
        cutoff_time = current_time - window_seconds
        return sum(1 for op in self.database_operations 
                  if (op.user_id == user_id and 
                      op.timestamp > cutoff_time and
                      op.table_name in self.sensitive_tables))
    
    def _get_severity_level(self, severity: str) -> int:
        """Get numeric severity level for comparison."""
        severity_levels = {
            "low": 1,
            "medium": 2,
            "high": 3,
            "critical": 4
        }
        return severity_levels.get(severity, 0)
    
    def _periodic_cleanup(self, current_time: float):
        """Periodically clean up old data."""
        if current_time - self.last_cleanup < self.cleanup_interval:
            return
        
        cutoff_time = current_time - self.config["max_storage_duration"]
        
        # Clean up old operations
        self.database_operations = [
            op for op in self.database_operations
            if op.timestamp > cutoff_time
        ]
        
        # Clean up old schema changes
        self.schema_changes = [
            change for change in self.schema_changes
            if change.timestamp > cutoff_time
        ]
        
        # Clean up old patterns
        expired_users = [
            user_id for user_id, patterns in self.user_operation_patterns.items()
            if patterns["last_operation"] < cutoff_time
        ]
        for user_id in expired_users:
            del self.user_operation_patterns[user_id]
        
        expired_tables = [
            table_name for table_name, patterns in self.table_access_patterns.items()
            if patterns["last_operation"] < cutoff_time
        ]
        for table_name in expired_tables:
            del self.table_access_patterns[table_name]
        
        self.last_cleanup = current_time
        logger.debug(f"Earth Wall cleanup completed")
    
    def get_integrity_summary(self) -> Dict:
        """Get summary of current data integrity status."""
        return {
            "total_operations": len(self.database_operations),
            "schema_changes": len(self.schema_changes),
            "monitored_users": len(self.user_operation_patterns),
            "monitored_tables": len(self.table_access_patterns),
            "sensitive_tables": len(self.sensitive_tables),
            "total_alerts": len(self.alerts),
            "config": self.config
        }
    
    def reset_integrity_data(self):
        """Reset all integrity data (useful for testing)."""
        self.database_operations.clear()
        self.schema_changes.clear()
        self.user_operation_patterns.clear()
        self.table_access_patterns.clear()
        self.alerts.clear()
        self.last_cleanup = time.time()
        logger.info("Earth Wall integrity data reset")
    
    def _broadcast_earth_wall_alert(self, alert: EarthWallAlert):
        """
        Broadcast Earth Wall alert via WebSocket to connected clients.
        
        This method integrates with the real-time alert system to provide
        instant notification of data integrity threats to security officers.
        
        Args:
            alert: EarthWallAlert object to broadcast
        """
        try:
            # Import here to avoid circular imports
            from realtime.alert_manager import broadcast_alert
            
            # Prepare alert data for WebSocket broadcasting
            alert_data = {
                "wall_name": "Earth Wall",
                "threat_level": alert.severity.lower(),
                "details": {
                    "alert_type": alert.alert_type,
                    "identifier": alert.identifier,
                    "username": alert.details.get("username", "unknown"),
                    "table_name": alert.details.get("table_name", "unknown"),
                    "operation_type": alert.details.get("operation_type", "unknown"),
                    "mitigation_action": alert.mitigation_action,
                    "timestamp": alert.timestamp.isoformat() if alert.timestamp else None
                },
                "source_wall": "earth_wall",
                "identifier": alert.identifier,
                "alert_type": alert.alert_type,
                "severity": alert.severity,
                "mitigation_action": alert.mitigation_action
            }
            
            # Broadcast alert asynchronously
            import asyncio
            try:
                loop = asyncio.get_event_loop()
                if loop.is_running():
                    # Create task for broadcasting
                    asyncio.create_task(broadcast_alert(alert_data))
                else:
                    # Run in new event loop if needed
                    asyncio.run(broadcast_alert(alert_data))
            except RuntimeError:
                # Fallback if no event loop is available
                logger.warning("No event loop available for alert broadcasting")
                
        except ImportError:
            logger.warning("Real-time alert manager not available")
        except Exception as e:
            logger.error(f"Error broadcasting Earth Wall alert: {e}")
