"""
Fire Wall - Authentication and Session Security

This module protects against authentication-based attacks:
- Brute-force login attempts
- Rapid failed login sequences
- Suspicious JWT token replay
- Account takeover attempts
- Session hijacking
- Credential stuffing attacks

The Fire Wall monitors authentication events and implements
progressive security measures to protect user accounts.
"""

import time
import logging
import hashlib
from typing import Dict, List, Optional, Set
from collections import defaultdict, deque
from dataclasses import dataclass
from datetime import datetime, timedelta
import json

logger = logging.getLogger(__name__)

@dataclass
class LoginAttempt:
    """Record of a login attempt."""
    timestamp: float
    ip_address: str
    username: str
    success: bool
    user_agent: str
    failure_reason: Optional[str] = None
    totp_used: bool = False

@dataclass
class JWTTokenRecord:
    """Record of JWT token usage."""
    token_hash: str
    user_id: str
    ip_address: str
    user_agent: str
    first_used: float
    last_used: float
    use_count: int = 1
    is_revoked: bool = False

@dataclass
class FireWallAlert:
    """Alert generated by Fire Wall detection."""
    alert_type: str
    severity: str  # low, medium, high, critical
    identifier: str  # username, IP, or token hash
    timestamp: datetime
    details: Dict
    mitigation_action: str
    block_duration: Optional[int] = None

class FireWall:
    """
    Fire Wall implementation for authentication and session security.
    
    Features:
    - Brute-force attack detection
    - JWT replay detection
    - Progressive account locking
    - IP-based blocking
    - User agent analysis
    - TOTP bypass detection
    """
    
    def __init__(self, config: Optional[Dict] = None):
        """
        Initialize Fire Wall with configuration.
        
        Args:
            config: Configuration dictionary with thresholds and settings
        """
        self.config = config or self._get_default_config()
        
        # Login attempt tracking
        self.login_attempts: Dict[str, List[LoginAttempt]] = defaultdict(list)  # username -> attempts
        self.ip_login_attempts: Dict[str, List[LoginAttempt]] = defaultdict(list)  # IP -> attempts
        
        # JWT token tracking
        self.active_tokens: Dict[str, JWTTokenRecord] = {}  # token_hash -> record
        self.revoked_tokens: Set[str] = set()
        
        # Blocked entities
        self.blocked_usernames: Dict[str, float] = {}  # username -> block_until
        self.blocked_ips: Dict[str, float] = {}  # IP -> block_until
        
        # Alert storage
        self.alerts: List[FireWallAlert] = []
        
        # Cleanup timer
        self.last_cleanup = time.time()
        self.cleanup_interval = 300  # 5 minutes
        
        logger.info("Fire Wall initialized with configuration: %s", self.config)
    
    def _get_default_config(self) -> Dict:
        """Get default configuration for Fire Wall."""
        return {
            # Login attempt thresholds
            "max_failed_logins_per_username": 5,
            "max_failed_logins_per_ip": 10,
            "failed_login_window_minutes": 15,
            "max_failed_logins_per_hour": 20,
            
            # Brute-force detection
            "brute_force_threshold": 3,  # failed attempts in short time
            "brute_force_window_seconds": 60,
            "rapid_failure_threshold": 5,  # failures in 1 minute
            
            # Account locking
            "account_lock_duration_minutes": 30,
            "progressive_lock_duration": True,
            "max_lock_duration_hours": 24,
            
            # IP blocking
            "ip_block_duration_minutes": 60,
            "max_ip_block_duration_hours": 48,
            
            # JWT security
            "jwt_replay_threshold": 3,  # same token used from different IPs
            "jwt_suspicious_use_threshold": 10,  # same token used too many times
            "jwt_geographic_anomaly": True,
            
            # TOTP security
            "totp_bypass_threshold": 2,  # failed TOTP attempts
            "require_totp_after_failures": 3,
            
            # Cleanup settings
            "cleanup_interval": 300,  # 5 minutes
            "max_storage_duration": 86400,  # 24 hours
            "max_login_attempts_stored": 1000,
        }
    
    def record_login_attempt(self, login_data: Dict) -> Optional[FireWallAlert]:
        """
        Record a login attempt and check for security threats.
        
        Args:
            login_data: Dictionary containing login attempt information
                - username: Username attempting to login
                - ip_address: IP address of the attempt
                - success: Whether login was successful
                - user_agent: User agent string
                - failure_reason: Reason for failure (if any)
                - totp_used: Whether TOTP was used
                - timestamp: Timestamp of attempt
        
        Returns:
            FireWallAlert if threat detected, None otherwise
        """
        try:
            current_time = time.time()
            
            # Extract login information
            username = login_data.get("username")
            ip_address = login_data.get("ip_address")
            success = login_data.get("success", False)
            user_agent = login_data.get("user_agent", "")
            failure_reason = login_data.get("failure_reason")
            totp_used = login_data.get("totp_used", False)
            timestamp = login_data.get("timestamp", current_time)
            
            if not username or not ip_address:
                logger.warning("Login attempt missing username or IP address")
                return None
            
            # Check if username or IP is currently blocked
            if self._is_blocked(username, ip_address, current_time):
                return FireWallAlert(
                    alert_type="blocked_entity_attempt",
                    severity="medium",
                    identifier=f"{username}:{ip_address}",
                    timestamp=datetime.fromtimestamp(current_time),
                    details={
                        "username": username,
                        "ip_address": ip_address,
                        "reason": "Entity currently blocked"
                    },
                    mitigation_action="maintain_block"
                )
            
            # Create login attempt record
            attempt = LoginAttempt(
                timestamp=timestamp,
                ip_address=ip_address,
                username=username,
                success=success,
                user_agent=user_agent,
                failure_reason=failure_reason,
                totp_used=totp_used
            )
            
            # Store the attempt
            self.login_attempts[username].append(attempt)
            self.ip_login_attempts[ip_address].append(attempt)
            
            # Limit stored attempts per entity
            self._limit_stored_attempts(username, ip_address)
            
            # Run security checks
            alerts = []
            
            if not success:
                # Failed login security checks
                brute_force_alert = self._detect_brute_force(username, ip_address, current_time)
                if brute_force_alert:
                    alerts.append(brute_force_alert)
                
                rapid_failure_alert = self._detect_rapid_failures(username, ip_address, current_time)
                if rapid_failure_alert:
                    alerts.append(rapid_failure_alert)
                
                totp_bypass_alert = self._detect_totp_bypass(username, ip_address, current_time)
                if totp_bypass_alert:
                    alerts.append(totp_bypass_alert)
            else:
                # Successful login security checks
                suspicious_success_alert = self._detect_suspicious_success(username, ip_address, current_time)
                if suspicious_success_alert:
                    alerts.append(suspicious_success_alert)
            
            # Return highest severity alert
            if alerts:
                highest_alert = max(alerts, key=lambda x: self._get_severity_level(x.severity))
                # Broadcast alert via WebSocket
                self._broadcast_fire_wall_alert(highest_alert)
                return highest_alert
            
            # Periodic cleanup
            self._periodic_cleanup(current_time)
            
            return None
            
        except Exception as e:
            logger.error(f"Error recording login attempt in Fire Wall: {str(e)}")
            return None
    
    def record_jwt_usage(self, jwt_data: Dict) -> Optional[FireWallAlert]:
        """
        Record JWT token usage and check for replay attacks.
        
        Args:
            jwt_data: Dictionary containing JWT usage information
                - token_hash: Hash of the JWT token
                - user_id: User ID from the token
                - ip_address: IP address using the token
                - user_agent: User agent string
                - timestamp: Timestamp of usage
        
        Returns:
            FireWallAlert if threat detected, None otherwise
        """
        try:
            current_time = time.time()
            
            # Extract JWT information
            token_hash = jwt_data.get("token_hash")
            user_id = jwt_data.get("user_id")
            ip_address = jwt_data.get("ip_address")
            user_agent = jwt_data.get("user_agent", "")
            timestamp = jwt_data.get("timestamp", current_time)
            
            if not token_hash or not user_id or not ip_address:
                logger.warning("JWT usage missing required fields")
                return None
            
            # Check if token is revoked
            if token_hash in self.revoked_tokens:
                return FireWallAlert(
                    alert_type="revoked_token_usage",
                    severity="high",
                    identifier=token_hash,
                    timestamp=datetime.fromtimestamp(current_time),
                    details={
                        "user_id": user_id,
                        "ip_address": ip_address,
                        "reason": "Token was previously revoked"
                    },
                    mitigation_action="revoke_token"
                )
            
            # Update or create token record
            if token_hash in self.active_tokens:
                token_record = self.active_tokens[token_hash]
                token_record.last_used = current_time
                token_record.use_count += 1
                
                # Check for suspicious usage patterns
                alerts = []
                
                # Check for IP changes (potential replay)
                if token_record.ip_address != ip_address:
                    ip_change_alert = self._detect_jwt_ip_change(token_record, ip_address, current_time)
                    if ip_change_alert:
                        alerts.append(ip_change_alert)
                
                # Check for excessive usage
                usage_alert = self._detect_excessive_jwt_usage(token_record, current_time)
                if usage_alert:
                    alerts.append(usage_alert)
                
                # Check for user agent changes
                if token_record.user_agent != user_agent:
                    ua_change_alert = self._detect_jwt_user_agent_change(token_record, user_agent, current_time)
                    if ua_change_alert:
                        alerts.append(ua_change_alert)
                
                if alerts:
                    return max(alerts, key=lambda x: self._get_severity_level(x.severity))
            else:
                # New token
                self.active_tokens[token_hash] = JWTTokenRecord(
                    token_hash=token_hash,
                    user_id=user_id,
                    ip_address=ip_address,
                    user_agent=user_agent,
                    first_used=current_time,
                    last_used=current_time
                )
            
            return None
            
        except Exception as e:
            logger.error(f"Error recording JWT usage in Fire Wall: {str(e)}")
            return None
    
    def _detect_brute_force(self, username: str, ip_address: str, current_time: float) -> Optional[FireWallAlert]:
        """Detect brute-force attacks against a username or IP."""
        # Username-based brute-force detection
        username_attempts = self.login_attempts[username]
        recent_failures = [
            attempt for attempt in username_attempts
            if not attempt.success and current_time - attempt.timestamp <= self.config["brute_force_window_seconds"]
        ]
        
        if len(recent_failures) >= self.config["brute_force_threshold"]:
            # Implement progressive account locking
            lock_duration = self._calculate_lock_duration(username)
            
            self.blocked_usernames[username] = current_time + (lock_duration * 60)
            
            return FireWallAlert(
                alert_type="brute_force_detected",
                severity="high",
                identifier=username,
                timestamp=datetime.fromtimestamp(current_time),
                details={
                    "failed_attempts": len(recent_failures),
                    "window_seconds": self.config["brute_force_window_seconds"],
                    "threshold": self.config["brute_force_threshold"],
                    "lock_duration_minutes": lock_duration
                },
                mitigation_action="account_lock",
                block_duration=lock_duration * 60
            )
        
        # IP-based brute-force detection
        ip_attempts = self.ip_login_attempts[ip_address]
        recent_ip_failures = [
            attempt for attempt in ip_attempts
            if not attempt.success and current_time - attempt.timestamp <= self.config["brute_force_window_seconds"]
        ]
        
        if len(recent_ip_failures) >= self.config["brute_force_threshold"]:
            lock_duration = self._calculate_ip_lock_duration(ip_address)
            
            self.blocked_ips[ip_address] = current_time + (lock_duration * 60)
            
            return FireWallAlert(
                alert_type="ip_brute_force_detected",
                severity="high",
                identifier=ip_address,
                timestamp=datetime.fromtimestamp(current_time),
                details={
                    "failed_attempts": len(recent_ip_failures),
                    "window_seconds": self.config["brute_force_window_seconds"],
                    "threshold": self.config["brute_force_threshold"],
                    "lock_duration_minutes": lock_duration
                },
                mitigation_action="ip_block",
                block_duration=lock_duration * 60
            )
        
        return None
    
    def _detect_rapid_failures(self, username: str, ip_address: str, current_time: float) -> Optional[FireWallAlert]:
        """Detect rapid failure patterns."""
        # Check for rapid failures in short time windows
        username_attempts = self.login_attempts[username]
        failures_last_minute = [
            attempt for attempt in username_attempts
            if not attempt.success and current_time - attempt.timestamp <= 60
        ]
        
        if len(failures_last_minute) >= self.config["rapid_failure_threshold"]:
            return FireWallAlert(
                alert_type="rapid_failures_detected",
                severity="medium",
                identifier=username,
                timestamp=datetime.fromtimestamp(current_time),
                details={
                    "failures_last_minute": len(failures_last_minute),
                    "threshold": self.config["rapid_failure_threshold"]
                },
                mitigation_action="temporary_throttling"
            )
        
        return None
    
    def _detect_totp_bypass(self, username: str, ip_address: str, current_time: float) -> Optional[FireWallAlert]:
        """Detect TOTP bypass attempts."""
        username_attempts = self.login_attempts[username]
        recent_failures = [
            attempt for attempt in username_attempts
            if not attempt.success and current_time - attempt.timestamp <= 300  # 5 minutes
        ]
        
        # Count failures without TOTP
        failures_without_totp = [attempt for attempt in recent_failures if not attempt.totp_used]
        
        if len(failures_without_totp) >= self.config["totp_bypass_threshold"]:
            return FireWallAlert(
                alert_type="totp_bypass_attempt",
                severity="medium",
                identifier=username,
                timestamp=datetime.fromtimestamp(current_time),
                details={
                    "failures_without_totp": len(failures_without_totp),
                    "threshold": self.config["totp_bypass_threshold"]
                },
                mitigation_action="require_totp"
            )
        
        return None
    
    def _detect_suspicious_success(self, username: str, ip_address: str, current_time: float) -> Optional[FireWallAlert]:
        """Detect suspicious successful logins."""
        username_attempts = self.login_attempts[username]
        
        # Check if this is a successful login after many failures
        recent_failures = [
            attempt for attempt in username_attempts
            if not attempt.success and current_time - attempt.timestamp <= 3600  # 1 hour
        ]
        
        if len(recent_failures) >= self.config["max_failed_logins_per_username"]:
            return FireWallAlert(
                alert_type="suspicious_successful_login",
                severity="medium",
                identifier=username,
                timestamp=datetime.fromtimestamp(current_time),
                details={
                    "recent_failures": len(recent_failures),
                    "ip_address": ip_address,
                    "pattern": "success_after_failures"
                },
                mitigation_action="monitor_account"
            )
        
        return None
    
    def _detect_jwt_ip_change(self, token_record: JWTTokenRecord, new_ip: str, current_time: float) -> Optional[FireWallAlert]:
        """Detect JWT token usage from different IP addresses."""
        if token_record.ip_address != new_ip:
            return FireWallAlert(
                alert_type="jwt_ip_change",
                severity="medium",
                identifier=token_record.token_hash,
                timestamp=datetime.fromtimestamp(current_time),
                details={
                    "original_ip": token_record.ip_address,
                    "new_ip": new_ip,
                    "user_id": token_record.user_id,
                    "pattern": "token_reuse_different_ip"
                },
                mitigation_action="monitor_token"
            )
        return None
    
    def _detect_excessive_jwt_usage(self, token_record: JWTTokenRecord, current_time: float) -> Optional[FireWallAlert]:
        """Detect excessive JWT token usage."""
        if token_record.use_count > self.config["jwt_suspicious_use_threshold"]:
            return FireWallAlert(
                alert_type="excessive_jwt_usage",
                severity="low",
                identifier=token_record.token_hash,
                timestamp=datetime.fromtimestamp(current_time),
                details={
                    "use_count": token_record.use_count,
                    "threshold": self.config["jwt_suspicious_use_threshold"],
                    "user_id": token_record.user_id
                },
                mitigation_action="review_token"
            )
        return None
    
    def _detect_jwt_user_agent_change(self, token_record: JWTTokenRecord, new_user_agent: str, current_time: float) -> Optional[FireWallAlert]:
        """Detect JWT token usage with different user agent."""
        if token_record.user_agent != new_user_agent:
            return FireWallAlert(
                alert_type="jwt_user_agent_change",
                severity="low",
                identifier=token_record.token_hash,
                timestamp=datetime.fromtimestamp(current_time),
                details={
                    "original_user_agent": token_record.user_agent,
                    "new_user_agent": new_user_agent,
                    "user_id": token_record.user_id,
                    "pattern": "token_reuse_different_ua"
                },
                mitigation_action="monitor_token"
            )
        return None
    
    def _calculate_lock_duration(self, username: str) -> int:
        """Calculate progressive lock duration for a username."""
        if not self.config["progressive_lock_duration"]:
            return self.config["account_lock_duration_minutes"]
        
        # Count previous locks
        lock_count = sum(1 for block_time in self.blocked_usernames.values() 
                        if block_time > time.time())
        
        # Progressive duration: 30min, 1hr, 2hr, 4hr, 8hr, 24hr
        durations = [30, 60, 120, 240, 480, 1440]  # minutes
        duration_index = min(lock_count, len(durations) - 1)
        
        return min(durations[duration_index], self.config["max_lock_duration_hours"] * 60)
    
    def _calculate_ip_lock_duration(self, ip_address: str) -> int:
        """Calculate progressive lock duration for an IP address."""
        lock_count = sum(1 for block_time in self.blocked_ips.values() 
                        if block_time > time.time())
        
        # Progressive duration: 1hr, 2hr, 4hr, 8hr, 24hr, 48hr
        durations = [60, 120, 240, 480, 1440, 2880]  # minutes
        duration_index = min(lock_count, len(durations) - 1)
        
        return min(durations[duration_index], self.config["max_ip_block_duration_hours"] * 60)
    
    def _is_blocked(self, username: str, ip_address: str, current_time: float) -> bool:
        """Check if username or IP is currently blocked."""
        # Check username block
        if username in self.blocked_usernames:
            if current_time < self.blocked_usernames[username]:
                return True
            else:
                # Block expired, remove it
                del self.blocked_usernames[username]
        
        # Check IP block
        if ip_address in self.blocked_ips:
            if current_time < self.blocked_ips[ip_address]:
                return True
            else:
                # Block expired, remove it
                del self.blocked_ips[ip_address]
        
        return False
    
    def _limit_stored_attempts(self, username: str, ip_address: str):
        """Limit the number of stored login attempts per entity."""
        max_attempts = self.config["max_login_attempts_stored"]
        
        if len(self.login_attempts[username]) > max_attempts:
            self.login_attempts[username] = self.login_attempts[username][-max_attempts:]
        
        if len(self.ip_login_attempts[ip_address]) > max_attempts:
            self.ip_login_attempts[ip_address] = self.ip_login_attempts[ip_address][-max_attempts:]
    
    def _get_severity_level(self, severity: str) -> int:
        """Get numeric severity level for comparison."""
        severity_levels = {
            "low": 1,
            "medium": 2,
            "high": 3,
            "critical": 4
        }
        return severity_levels.get(severity, 0)
    
    def _periodic_cleanup(self, current_time: float):
        """Periodically clean up old data."""
        if current_time - self.last_cleanup < self.cleanup_interval:
            return
        
        cutoff_time = current_time - self.config["max_storage_duration"]
        
        # Clean up old login attempts
        for username in list(self.login_attempts.keys()):
            self.login_attempts[username] = [
                attempt for attempt in self.login_attempts[username]
                if attempt.timestamp > cutoff_time
            ]
            if not self.login_attempts[username]:
                del self.login_attempts[username]
        
        for ip_address in list(self.ip_login_attempts.keys()):
            self.ip_login_attempts[ip_address] = [
                attempt for attempt in self.ip_login_attempts[ip_address]
                if attempt.timestamp > cutoff_time
            ]
            if not self.ip_login_attempts[ip_address]:
                del self.ip_login_attempts[ip_address]
        
        # Clean up old JWT tokens
        expired_tokens = [
            token_hash for token_hash, record in self.active_tokens.items()
            if current_time - record.last_used > self.config["max_storage_duration"]
        ]
        for token_hash in expired_tokens:
            del self.active_tokens[token_hash]
        
        self.last_cleanup = current_time
        logger.debug(f"Fire Wall cleanup completed")
    
    def revoke_token(self, token_hash: str):
        """Revoke a JWT token."""
        if token_hash in self.active_tokens:
            del self.active_tokens[token_hash]
        self.revoked_tokens.add(token_hash)
        logger.info(f"JWT token revoked: {token_hash}")
    
    def get_security_summary(self) -> Dict:
        """Get summary of current security status."""
        return {
            "blocked_usernames": len(self.blocked_usernames),
            "blocked_ips": len(self.blocked_ips),
            "active_tokens": len(self.active_tokens),
            "revoked_tokens": len(self.revoked_tokens),
            "total_alerts": len(self.alerts),
            "config": self.config
        }
    
    def reset_security_data(self):
        """Reset all security data (useful for testing)."""
        self.login_attempts.clear()
        self.ip_login_attempts.clear()
        self.active_tokens.clear()
        self.revoked_tokens.clear()
        self.blocked_usernames.clear()
        self.blocked_ips.clear()
        self.alerts.clear()
        self.last_cleanup = time.time()
        logger.info("Fire Wall security data reset")
    
    def _broadcast_fire_wall_alert(self, alert: FireWallAlert):
        """
        Broadcast Fire Wall alert via WebSocket to connected clients.
        
        This method integrates with the real-time alert system to provide
        instant notification of authentication threats to security officers.
        
        Args:
            alert: FireWallAlert object to broadcast
        """
        try:
            # Import here to avoid circular imports
            from realtime.alert_manager import broadcast_alert
            
            # Prepare alert data for WebSocket broadcasting
            alert_data = {
                "wall_name": "Fire Wall",
                "threat_level": alert.severity.lower(),
                "details": {
                    "alert_type": alert.alert_type,
                    "identifier": alert.identifier,
                    "username": alert.details.get("username", "unknown"),
                    "ip_address": alert.details.get("ip_address", "unknown"),
                    "failure_reason": alert.details.get("failure_reason", "unknown"),
                    "mitigation_action": alert.mitigation_action,
                    "block_duration": alert.block_duration,
                    "timestamp": alert.timestamp.isoformat() if alert.timestamp else None
                },
                "source_wall": "fire_wall",
                "identifier": alert.identifier,
                "alert_type": alert.alert_type,
                "severity": alert.severity,
                "mitigation_action": alert.mitigation_action
            }
            
            # Broadcast alert asynchronously
            import asyncio
            try:
                loop = asyncio.get_event_loop()
                if loop.is_running():
                    # Create task for broadcasting
                    asyncio.create_task(broadcast_alert(alert_data))
                else:
                    # Run in new event loop if needed
                    asyncio.run(broadcast_alert(alert_data))
            except RuntimeError:
                # Fallback if no event loop is available
                logger.warning("No event loop available for alert broadcasting")
                
        except ImportError:
            logger.warning("Real-time alert manager not available")
        except Exception as e:
            logger.error(f"Error broadcasting Fire Wall alert: {e}")
