"""
Water Wall - API Misuse Detection and Dynamic IP Management

This module monitors API usage patterns to detect and mitigate:
- API misuse and abuse
- Repeated malicious actions
- Dynamic IP blacklisting
- Rate limiting violations
- Unusual API call patterns
- Geographic abuse patterns

The Water Wall adapts to threats by dynamically adjusting
security measures based on observed behavior patterns.
"""

import time
import logging
import hashlib
from typing import Dict, List, Optional, Set
from collections import defaultdict, deque
from dataclasses import dataclass
from datetime import datetime, timedelta
import json

logger = logging.getLogger(__name__)

@dataclass
class APIRequest:
    """Record of an API request."""
    timestamp: float
    ip_address: str
    user_id: Optional[str]
    endpoint: str
    method: str
    status_code: int
    response_time_ms: float
    request_size: int
    user_agent: str
    headers: Dict
    geo_data: Optional[Dict] = None

@dataclass
class IPReputation:
    """IP address reputation tracking."""
    ip_address: str
    first_seen: float
    last_seen: float
    total_requests: int
    successful_requests: int
    failed_requests: int
    suspicious_requests: int
    reputation_score: float
    is_blacklisted: bool
    blacklist_reason: Optional[str] = None
    blacklist_timestamp: Optional[float] = None
    whitelist_until: Optional[float] = None

@dataclass
class WaterWallAlert:
    """Alert generated by Water Wall detection."""
    alert_type: str
    severity: str  # low, medium, high, critical
    identifier: str  # IP address or user_id
    timestamp: datetime
    details: Dict
    mitigation_action: str
    blacklist_duration: Optional[int] = None

class WaterWall:
    """
    Water Wall implementation for API misuse detection and dynamic IP management.
    
    Features:
    - API abuse detection
    - Dynamic IP blacklisting
    - Reputation scoring
    - Geographic pattern analysis
    - Adaptive security measures
    - Whitelist management
    """
    
    def __init__(self, config: Optional[Dict] = None):
        """
        Initialize Water Wall with configuration.
        
        Args:
            config: Configuration dictionary with thresholds and settings
        """
        self.config = config or self._get_default_config()
        
        # Request tracking
        self.api_requests: List[APIRequest] = []
        self.ip_reputations: Dict[str, IPReputation] = {}
        
        # Endpoint monitoring
        self.endpoint_patterns: Dict[str, Dict] = defaultdict(dict)
        
        # Blacklist and whitelist
        self.blacklisted_ips: Set[str] = set()
        self.whitelisted_ips: Dict[str, float] = {}  # IP -> whitelist_until
        
        # Alert storage
        self.alerts: List[WaterWallAlert] = []
        
        # Cleanup timer
        self.last_cleanup = time.time()
        self.cleanup_interval = 300  # 5 minutes
        
        logger.info("Water Wall initialized with configuration: %s", self.config)
    
    def _get_default_config(self) -> Dict:
        """Get default configuration for Water Wall."""
        return {
            # API abuse detection thresholds
            "max_requests_per_ip_per_minute": 60,
            "max_requests_per_ip_per_hour": 1000,
            "max_failed_requests_per_ip_per_hour": 50,
            "max_suspicious_requests_per_ip_per_hour": 20,
            
            # Reputation scoring
            "initial_reputation_score": 100.0,
            "reputation_decay_rate": 0.95,  # per hour
            "min_reputation_score": 0.0,
            "max_reputation_score": 100.0,
            
            # Blacklisting thresholds
            "blacklist_threshold": 20.0,  # reputation score
            "auto_blacklist_enabled": True,
            "blacklist_duration_hours": 24,
            "progressive_blacklist": True,
            
            # Whitelist management
            "auto_whitelist_enabled": True,
            "whitelist_threshold": 80.0,  # reputation score
            "whitelist_duration_hours": 6,
            
            # Geographic abuse detection
            "enable_geo_tracking": True,
            "geo_abuse_threshold": 100,  # requests from same region per hour
            "suspicious_countries": [],  # list of suspicious country codes
            
            # Endpoint abuse detection
            "sensitive_endpoints": ["/admin", "/user/delete", "/payment"],
            "endpoint_abuse_threshold": 10,  # requests to sensitive endpoint per hour
            
            # Response time monitoring
            "suspicious_response_time_ms": 5000,  # 5 seconds
            "response_time_abuse_threshold": 5,  # suspicious responses per hour
            
            # Cleanup settings
            "cleanup_interval": 300,  # 5 minutes
            "max_storage_duration": 86400,  # 24 hours
            "max_requests_stored": 10000,
        }
    
    def monitor_request(self, request_data: Dict) -> Optional[WaterWallAlert]:
        """
        Monitor an API request for misuse patterns.
        
        Args:
            request_data: Dictionary containing request information
                - ip_address: Client IP address
                - user_id: User identifier (if authenticated)
                - endpoint: API endpoint being accessed
                - method: HTTP method
                - status_code: HTTP response status code
                - response_time_ms: Response time in milliseconds
                - request_size: Size of request in bytes
                - user_agent: User agent string
                - headers: Request headers
                - geo_data: Geographic data (optional)
        
        Returns:
            WaterWallAlert if threat detected, None otherwise
        """
        try:
            current_time = time.time()
            
            # Extract request information
            ip_address = request_data.get("ip_address")
            user_id = request_data.get("user_id")
            endpoint = request_data.get("endpoint")
            method = request_data.get("method", "GET")
            status_code = request_data.get("status_code", 200)
            response_time_ms = request_data.get("response_time_ms", 0)
            request_size = request_data.get("request_size", 0)
            user_agent = request_data.get("user_agent", "")
            headers = request_data.get("headers", {})
            geo_data = request_data.get("geo_data", {})
            
            if not ip_address or not endpoint:
                logger.warning("API request missing IP address or endpoint")
                return None
            
            # Check if IP is blacklisted
            if ip_address in self.blacklisted_ips:
                return WaterWallAlert(
                    alert_type="blacklisted_ip_access",
                    severity="medium",
                    identifier=ip_address,
                    timestamp=datetime.fromtimestamp(current_time),
                    details={
                        "endpoint": endpoint,
                        "method": method,
                        "reason": "IP is blacklisted"
                    },
                    mitigation_action="maintain_blacklist"
                )
            
            # Create request record
            request = APIRequest(
                timestamp=current_time,
                ip_address=ip_address,
                user_id=user_id,
                endpoint=endpoint,
                method=method,
                status_code=status_code,
                response_time_ms=response_time_ms,
                request_size=request_size,
                user_agent=user_agent,
                headers=headers,
                geo_data=geo_data
            )
            
            # Store the request
            self.api_requests.append(request)
            
            # Limit stored requests
            if len(self.api_requests) > self.config["max_requests_stored"]:
                self.api_requests = self.api_requests[-self.config["max_requests_stored"]:]
            
            # Update IP reputation
            self._update_ip_reputation(request, current_time)
            
            # Update endpoint patterns
            self._update_endpoint_patterns(request, current_time)
            
            # Run security checks
            alerts = []
            
            # Rate limiting checks
            rate_alert = self._check_rate_limiting(ip_address, current_time)
            if rate_alert:
                alerts.append(rate_alert)
            
            # Failed request monitoring
            if status_code >= 400:
                failed_alert = self._monitor_failed_requests(ip_address, current_time)
                if failed_alert:
                    alerts.append(failed_alert)
            
            # Suspicious response time detection
            if response_time_ms > self.config["suspicious_response_time_ms"]:
                response_time_alert = self._detect_suspicious_response_times(ip_address, current_time)
                if response_time_alert:
                    alerts.append(response_time_alert)
            
            # Sensitive endpoint abuse detection
            if endpoint in self.config["sensitive_endpoints"]:
                endpoint_alert = self._detect_sensitive_endpoint_abuse(ip_address, endpoint, current_time)
                if endpoint_alert:
                    alerts.append(endpoint_alert)
            
            # Geographic abuse detection
            geo_alert = self._detect_geographic_abuse(ip_address, geo_data, current_time)
            if geo_alert:
                alerts.append(geo_alert)
            
            # Reputation-based blacklisting
            reputation_alert = self._check_reputation_thresholds(ip_address, current_time)
            if reputation_alert:
                alerts.append(reputation_alert)
            
            # Return highest severity alert
            if alerts:
                highest_alert = max(alerts, key=lambda x: self._get_severity_level(x.severity))
                # Broadcast alert via WebSocket
                self._broadcast_water_wall_alert(highest_alert)
                return highest_alert
            
            # Periodic cleanup
            self._periodic_cleanup(current_time)
            
            return None
            
        except Exception as e:
            logger.error(f"Error monitoring request in Water Wall: {str(e)}")
            return None
    
    def _update_ip_reputation(self, request: APIRequest, current_time: float):
        """Update IP address reputation based on request."""
        if request.ip_address not in self.ip_reputations:
            self.ip_reputations[request.ip_address] = IPReputation(
                ip_address=request.ip_address,
                first_seen=current_time,
                last_seen=current_time,
                total_requests=0,
                successful_requests=0,
                failed_requests=0,
                suspicious_requests=0,
                reputation_score=self.config["initial_reputation_score"],
                is_blacklisted=False
            )
        
        reputation = self.ip_reputations[request.ip_address]
        reputation.last_seen = current_time
        reputation.total_requests += 1
        
        # Update reputation based on response
        if request.status_code < 400:
            reputation.successful_requests += 1
            # Slight reputation boost for successful requests
            reputation.reputation_score = min(
                reputation.reputation_score + 0.1,
                self.config["max_reputation_score"]
            )
        else:
            reputation.failed_requests += 1
            # Reputation penalty for failed requests
            reputation.reputation_score = max(
                reputation.reputation_score - 1.0,
                self.config["min_reputation_score"]
            )
        
        # Check for suspicious patterns
        if self._is_suspicious_request(request):
            reputation.suspicious_requests += 1
            # Significant reputation penalty for suspicious requests
            reputation.reputation_score = max(
                reputation.reputation_score - 5.0,
                self.config["min_reputation_score"]
            )
        
        # Apply reputation decay
        hours_since_last_seen = (current_time - reputation.last_seen) / 3600
        if hours_since_last_seen > 0:
            reputation.reputation_score *= (self.config["reputation_decay_rate"] ** hours_since_last_seen)
            reputation.reputation_score = max(reputation.reputation_score, self.config["min_reputation_score"])
    
    def _update_endpoint_patterns(self, request: APIRequest, current_time: float):
        """Update endpoint access patterns."""
        if request.endpoint not in self.endpoint_patterns:
            self.endpoint_patterns[request.endpoint] = {
                "total_requests": 0,
                "requests_by_ip": defaultdict(int),
                "requests_by_method": defaultdict(int),
                "last_request": 0,
                "first_request": 0
            }
        
        patterns = self.endpoint_patterns[request.endpoint]
        patterns["total_requests"] += 1
        patterns["requests_by_ip"][request.ip_address] += 1
        patterns["requests_by_method"][request.method] += 1
        patterns["last_request"] = current_time
        
        if patterns["first_request"] == 0:
            patterns["first_request"] = current_time
    
    def _is_suspicious_request(self, request: APIRequest) -> bool:
        """Determine if a request is suspicious."""
        # Check for suspicious user agents
        suspicious_user_agents = [
            "bot", "crawler", "scraper", "spider", "curl", "wget",
            "python-requests", "java", "perl", "ruby"
        ]
        
        user_agent_lower = request.user_agent.lower()
        if any(agent in user_agent_lower for agent in suspicious_user_agents):
            return True
        
        # Check for suspicious headers
        suspicious_headers = ["x-forwarded-for", "x-real-ip", "cf-connecting-ip"]
        if any(header in request.headers for header in suspicious_headers):
            return True
        
        # Check for unusually large requests
        if request.request_size > 1048576:  # 1MB
            return True
        
        return False
    
    def _check_rate_limiting(self, ip_address: str, current_time: float) -> Optional[WaterWallAlert]:
        """Check if request violates rate limiting thresholds."""
        # Count requests in time windows
        requests_last_minute = self._count_requests_in_window(ip_address, current_time, 60)
        requests_last_hour = self._count_requests_in_window(ip_address, current_time, 3600)
        
        if requests_last_minute > self.config["max_requests_per_ip_per_minute"]:
            return WaterWallAlert(
                alert_type="rate_limit_exceeded",
                severity="medium",
                identifier=ip_address,
                timestamp=datetime.fromtimestamp(current_time),
                details={
                    "requests_last_minute": requests_last_minute,
                    "limit": self.config["max_requests_per_ip_per_minute"]
                },
                mitigation_action="temporary_throttling"
            )
        
        if requests_last_hour > self.config["max_requests_per_ip_per_hour"]:
            return WaterWallAlert(
                alert_type="rate_limit_exceeded",
                severity="high",
                identifier=ip_address,
                timestamp=datetime.fromtimestamp(current_time),
                details={
                    "requests_last_hour": requests_last_hour,
                    "limit": self.config["max_requests_per_ip_per_hour"]
                },
                mitigation_action="extended_throttling"
            )
        
        return None
    
    def _monitor_failed_requests(self, ip_address: str, current_time: float) -> Optional[WaterWallAlert]:
        """Monitor failed requests for abuse patterns."""
        failed_requests_last_hour = self._count_failed_requests_in_window(ip_address, current_time, 3600)
        
        if failed_requests_last_hour > self.config["max_failed_requests_per_ip_per_hour"]:
            return WaterWallAlert(
                alert_type="excessive_failed_requests",
                severity="medium",
                identifier=ip_address,
                timestamp=datetime.fromtimestamp(current_time),
                details={
                    "failed_requests_last_hour": failed_requests_last_hour,
                    "limit": self.config["max_failed_requests_per_ip_per_hour"]
                },
                mitigation_action="monitor_ip"
            )
        
        return None
    
    def _detect_suspicious_response_times(self, ip_address: str, current_time: float) -> Optional[WaterWallAlert]:
        """Detect suspicious response time patterns."""
        suspicious_responses_last_hour = self._count_suspicious_response_times_in_window(ip_address, current_time, 3600)
        
        if suspicious_responses_last_hour > self.config["response_time_abuse_threshold"]:
            return WaterWallAlert(
                alert_type="suspicious_response_times",
                severity="low",
                identifier=ip_address,
                timestamp=datetime.fromtimestamp(current_time),
                details={
                    "suspicious_responses_last_hour": suspicious_responses_last_hour,
                    "threshold": self.config["response_time_abuse_threshold"]
                },
                mitigation_action="investigate_performance"
            )
        
        return None
    
    def _detect_sensitive_endpoint_abuse(self, ip_address: str, endpoint: str, current_time: float) -> Optional[WaterWallAlert]:
        """Detect abuse of sensitive endpoints."""
        sensitive_requests_last_hour = self._count_sensitive_endpoint_requests_in_window(ip_address, endpoint, current_time, 3600)
        
        if sensitive_requests_last_hour > self.config["endpoint_abuse_threshold"]:
            return WaterWallAlert(
                alert_type="sensitive_endpoint_abuse",
                severity="high",
                identifier=f"{ip_address}:{endpoint}",
                timestamp=datetime.fromtimestamp(current_time),
                details={
                    "endpoint": endpoint,
                    "sensitive_requests_last_hour": sensitive_requests_last_hour,
                    "threshold": self.config["endpoint_abuse_threshold"]
                },
                mitigation_action="restrict_access"
            )
        
        return None
    
    def _detect_geographic_abuse(self, ip_address: str, geo_data: Dict, current_time: float) -> Optional[WaterWallAlert]:
        """Detect geographic abuse patterns."""
        if not self.config["enable_geo_tracking"] or not geo_data:
            return None
        
        country = geo_data.get("country")
        if country in self.config["suspicious_countries"]:
            return WaterWallAlert(
                alert_type="suspicious_geographic_location",
                severity="medium",
                identifier=ip_address,
                timestamp=datetime.fromtimestamp(current_time),
                details={
                    "country": country,
                    "reason": "Suspicious geographic location"
                },
                mitigation_action="geographic_restriction"
            )
        
        # Check for geographic clustering abuse
        if country:
            requests_from_country_last_hour = self._count_requests_from_country_in_window(country, current_time, 3600)
            
            if requests_from_country_last_hour > self.config["geo_abuse_threshold"]:
                return WaterWallAlert(
                    alert_type="geographic_abuse",
                    severity="medium",
                    identifier=f"country:{country}",
                    timestamp=datetime.fromtimestamp(current_time),
                    details={
                        "country": country,
                        "requests_last_hour": requests_from_country_last_hour,
                        "threshold": self.config["geo_abuse_threshold"]
                    },
                    mitigation_action="geographic_throttling"
                )
        
        return None
    
    def _check_reputation_thresholds(self, ip_address: str, current_time: float) -> Optional[WaterWallAlert]:
        """Check reputation thresholds for automatic actions."""
        if ip_address not in self.ip_reputations:
            return None
        
        reputation = self.ip_reputations[ip_address]
        
        # Check for blacklisting
        if (self.config["auto_blacklist_enabled"] and 
            reputation.reputation_score <= self.config["blacklist_threshold"] and
            not reputation.is_blacklisted):
            
            # Calculate blacklist duration
            blacklist_duration = self._calculate_blacklist_duration(ip_address)
            
            # Blacklist the IP
            self.blacklisted_ips.add(ip_address)
            reputation.is_blacklisted = True
            reputation.blacklist_reason = "Low reputation score"
            reputation.blacklist_timestamp = current_time
            
            return WaterWallAlert(
                alert_type="ip_auto_blacklisted",
                severity="high",
                identifier=ip_address,
                timestamp=datetime.fromtimestamp(current_time),
                details={
                    "reputation_score": reputation.reputation_score,
                    "threshold": self.config["blacklist_threshold"],
                    "blacklist_duration_hours": blacklist_duration,
                    "reason": "Low reputation score"
                },
                mitigation_action="blacklist_ip",
                blacklist_duration=blacklist_duration * 3600
            )
        
        # Check for whitelisting
        if (self.config["auto_whitelist_enabled"] and 
            reputation.reputation_score >= self.config["whitelist_threshold"] and
            ip_address not in self.whitelisted_ips):
            
            whitelist_duration = self.config["whitelist_duration_hours"]
            self.whitelisted_ips[ip_address] = current_time + (whitelist_duration * 3600)
            
            return WaterWallAlert(
                alert_type="ip_auto_whitelisted",
                severity="low",
                identifier=ip_address,
                timestamp=datetime.fromtimestamp(current_time),
                details={
                    "reputation_score": reputation.reputation_score,
                    "threshold": self.config["whitelist_threshold"],
                    "whitelist_duration_hours": whitelist_duration
                },
                mitigation_action="whitelist_ip"
            )
        
        return None
    
    def _calculate_blacklist_duration(self, ip_address: str) -> int:
        """Calculate progressive blacklist duration."""
        if not self.config["progressive_blacklist"]:
            return self.config["blacklist_duration_hours"]
        
        # Count previous blacklists
        blacklist_count = sum(1 for ip in self.blacklisted_ips)
        
        # Progressive duration: 24hr, 48hr, 72hr, 1 week, 2 weeks, 1 month
        durations = [24, 48, 72, 168, 336, 720]  # hours
        duration_index = min(blacklist_count, len(durations) - 1)
        
        return durations[duration_index]
    
    def _count_requests_in_window(self, ip_address: str, current_time: float, window_seconds: int) -> int:
        """Count requests from an IP within a time window."""
        cutoff_time = current_time - window_seconds
        return sum(1 for req in self.api_requests 
                  if req.ip_address == ip_address and req.timestamp > cutoff_time)
    
    def _count_failed_requests_in_window(self, ip_address: str, current_time: float, window_seconds: int) -> int:
        """Count failed requests from an IP within a time window."""
        cutoff_time = current_time - window_seconds
        return sum(1 for req in self.api_requests 
                  if (req.ip_address == ip_address and 
                      req.timestamp > cutoff_time and 
                      req.status_code >= 400))
    
    def _count_suspicious_response_times_in_window(self, ip_address: str, current_time: float, window_seconds: int) -> int:
        """Count suspicious response times from an IP within a time window."""
        cutoff_time = current_time - window_seconds
        return sum(1 for req in self.api_requests 
                  if (req.ip_address == ip_address and 
                      req.timestamp > cutoff_time and 
                      req.response_time_ms > self.config["suspicious_response_time_ms"]))
    
    def _count_sensitive_endpoint_requests_in_window(self, ip_address: str, endpoint: str, current_time: float, window_seconds: int) -> int:
        """Count sensitive endpoint requests from an IP within a time window."""
        cutoff_time = current_time - window_seconds
        return sum(1 for req in self.api_requests 
                  if (req.ip_address == ip_address and 
                      req.endpoint == endpoint and 
                      req.timestamp > cutoff_time))
    
    def _count_requests_from_country_in_window(self, country: str, current_time: float, window_seconds: int) -> int:
        """Count requests from a country within a time window."""
        cutoff_time = current_time - window_seconds
        return sum(1 for req in self.api_requests 
                  if (req.geo_data and 
                      req.geo_data.get("country") == country and 
                      req.timestamp > cutoff_time))
    
    def _get_severity_level(self, severity: str) -> int:
        """Get numeric severity level for comparison."""
        severity_levels = {
            "low": 1,
            "medium": 2,
            "high": 3,
            "critical": 4
        }
        return severity_levels.get(severity, 0)
    
    def _periodic_cleanup(self, current_time: float):
        """Periodically clean up old data."""
        if current_time - self.last_cleanup < self.cleanup_interval:
            return
        
        cutoff_time = current_time - self.config["max_storage_duration"]
        
        # Clean up old requests
        self.api_requests = [
            req for req in self.api_requests
            if req.timestamp > cutoff_time
        ]
        
        # Clean up expired whitelist entries
        expired_whitelist = [
            ip for ip, expiry in self.whitelisted_ips.items()
            if current_time > expiry
        ]
        for ip in expired_whitelist:
            del self.whitelisted_ips[ip]
        
        # Clean up old IP reputations
        expired_reputations = [
            ip for ip, reputation in self.ip_reputations.items()
            if current_time - reputation.last_seen > self.config["max_storage_duration"]
        ]
        for ip in expired_reputations:
            del self.ip_reputations[ip]
        
        self.last_cleanup = current_time
        logger.debug(f"Water Wall cleanup completed")
    
    def blacklist_ip(self, ip_address: str, reason: str, duration_hours: int = 24):
        """Manually blacklist an IP address."""
        self.blacklisted_ips.add(ip_address)
        
        if ip_address in self.ip_reputations:
            reputation = self.ip_reputations[ip_address]
            reputation.is_blacklisted = True
            reputation.blacklist_reason = reason
            reputation.blacklist_timestamp = time.time()
        
        logger.info(f"IP {ip_address} manually blacklisted: {reason}")
    
    def whitelist_ip(self, ip_address: str, duration_hours: int = 6):
        """Manually whitelist an IP address."""
        whitelist_until = time.time() + (duration_hours * 3600)
        self.whitelisted_ips[ip_address] = whitelist_until
        
        # Remove from blacklist if present
        if ip_address in self.blacklisted_ips:
            self.blacklisted_ips.remove(ip_address)
            
            if ip_address in self.ip_reputations:
                reputation = self.ip_reputations[ip_address]
                reputation.is_blacklisted = False
                reputation.blacklist_reason = None
                reputation.blacklist_timestamp = None
        
        logger.info(f"IP {ip_address} manually whitelisted for {duration_hours} hours")
    
    def get_api_summary(self) -> Dict:
        """Get summary of current API security status."""
        return {
            "total_requests": len(self.api_requests),
            "monitored_ips": len(self.ip_reputations),
            "blacklisted_ips": len(self.blacklisted_ips),
            "whitelisted_ips": len(self.whitelisted_ips),
            "monitored_endpoints": len(self.endpoint_patterns),
            "total_alerts": len(self.alerts),
            "config": self.config
        }
    
    def reset_api_data(self):
        """Reset all API data (useful for testing)."""
        self.api_requests.clear()
        self.ip_reputations.clear()
        self.endpoint_patterns.clear()
        self.blacklisted_ips.clear()
        self.whitelisted_ips.clear()
        self.alerts.clear()
        self.last_cleanup = time.time()
        logger.info("Water Wall API data reset")
    
    def _broadcast_water_wall_alert(self, alert: WaterWallAlert):
        """
        Broadcast Water Wall alert via WebSocket to connected clients.
        
        This method integrates with the real-time alert system to provide
        instant notification of API abuse threats to security officers.
        
        Args:
            alert: WaterWallAlert object to broadcast
        """
        try:
            # Import here to avoid circular imports
            from realtime.alert_manager import broadcast_alert
            
            # Prepare alert data for WebSocket broadcasting
            alert_data = {
                "wall_name": "Water Wall",
                "threat_level": alert.severity.lower(),
                "details": {
                    "alert_type": alert.alert_type,
                    "identifier": alert.identifier,
                    "endpoint": alert.details.get("endpoint", "unknown"),
                    "ip_address": alert.details.get("ip_address", "unknown"),
                    "country": alert.details.get("country", "unknown"),
                    "mitigation_action": alert.mitigation_action,
                    "timestamp": alert.timestamp.isoformat() if alert.timestamp else None
                },
                "source_wall": "water_wall",
                "identifier": alert.identifier,
                "alert_type": alert.alert_type,
                "severity": alert.severity,
                "mitigation_action": alert.mitigation_action
            }
            
            # Broadcast alert asynchronously
            import asyncio
            try:
                loop = asyncio.get_event_loop()
                if loop.is_running():
                    # Create task for broadcasting
                    asyncio.create_task(broadcast_alert(alert_data))
                else:
                    # Run in new event loop if needed
                    asyncio.run(broadcast_alert(alert_data))
            except RuntimeError:
                # Fallback if no event loop is available
                logger.warning("No event loop available for alert broadcasting")
                
        except ImportError:
            logger.warning("Real-time alert manager not available")
        except Exception as e:
            logger.error(f"Error broadcasting Water Wall alert: {e}")
