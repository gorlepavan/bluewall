"""
Air Wall - Network Traffic Analysis and DDoS Protection

This module monitors network traffic patterns to detect and mitigate:
- Abnormal request velocity (rate limiting violations)
- DDoS attack patterns (distributed denial of service)
- Packet floods and network anomalies
- Geographic clustering of malicious requests
- Unusual traffic spikes and patterns

The Air Wall acts as the first line of defense, analyzing traffic
before it reaches the application layer.
"""

import time
import logging
from typing import Dict, List, Optional, Tuple
from collections import defaultdict, deque
from dataclasses import dataclass
from datetime import datetime, timedelta
import ipaddress
import json

logger = logging.getLogger(__name__)

@dataclass
class TrafficMetrics:
    """Traffic metrics for a specific identifier (IP, user, endpoint)."""
    request_count: int = 0
    first_request: float = 0.0
    last_request: float = 0.0
    request_times: deque = None
    total_bytes: int = 0
    unique_endpoints: set = None
    
    def __post_init__(self):
        if self.request_times is None:
            self.request_times = deque(maxlen=1000)  # Keep last 1000 requests
        if self.unique_endpoints is None:
            self.unique_endpoints = set()

@dataclass
class AirWallAlert:
    """Alert generated by Air Wall detection."""
    alert_type: str
    severity: str  # low, medium, high, critical
    identifier: str  # IP, user_id, or endpoint
    timestamp: datetime
    details: Dict
    mitigation_action: str

class AirWall:
    """
    Air Wall implementation for network traffic analysis and DDoS protection.
    
    Features:
    - Real-time traffic monitoring
    - Adaptive rate limiting
    - DDoS pattern detection
    - Geographic clustering analysis
    - Automatic mitigation actions
    """
    
    def __init__(self, config: Optional[Dict] = None):
        """
        Initialize Air Wall with configuration.
        
        Args:
            config: Configuration dictionary with thresholds and settings
        """
        self.config = config or self._get_default_config()
        
        # Traffic tracking storage
        self.ip_traffic: Dict[str, TrafficMetrics] = defaultdict(TrafficMetrics)
        self.user_traffic: Dict[str, TrafficMetrics] = defaultdict(TrafficMetrics)
        self.endpoint_traffic: Dict[str, TrafficMetrics] = defaultdict(TrafficMetrics)
        
        # Alert storage
        self.alerts: List[AirWallAlert] = []
        
        # Cleanup timer
        self.last_cleanup = time.time()
        self.cleanup_interval = 300  # 5 minutes
        
        logger.info("Air Wall initialized with configuration: %s", self.config)
    
    def _get_default_config(self) -> Dict:
        """Get default configuration for Air Wall."""
        return {
            # Rate limiting thresholds
            "max_requests_per_minute": 60,
            "max_requests_per_hour": 1000,
            "max_requests_per_day": 10000,
            
            # DDoS detection thresholds
            "ddos_burst_threshold": 100,  # requests in 1 second
            "ddos_sustained_threshold": 500,  # requests in 1 minute
            "ddos_geographic_cluster": 50,  # requests from same region in 1 minute
            
            # Packet flood detection
            "max_packet_size": 1048576,  # 1MB
            "max_concurrent_connections": 10,
            
            # Geographic clustering
            "enable_geo_tracking": True,
            "geo_cluster_threshold": 20,
            
            # Mitigation actions
            "auto_block_duration": 3600,  # 1 hour
            "progressive_penalty": True,
            
            # Cleanup settings
            "cleanup_interval": 300,  # 5 minutes
            "max_storage_duration": 86400,  # 24 hours
        }
    
    def analyze_request(self, request_data: Dict) -> Optional[AirWallAlert]:
        """
        Analyze a single request for potential threats.
        
        Args:
            request_data: Dictionary containing request information
                - ip_address: Client IP address
                - user_id: User identifier (if authenticated)
                - endpoint: API endpoint being accessed
                - timestamp: Request timestamp
                - request_size: Size of request in bytes
                - user_agent: User agent string
                - geo_data: Geographic data (optional)
        
        Returns:
            AirWallAlert if threat detected, None otherwise
        """
        try:
            current_time = time.time()
            
            # Extract request information
            ip_address = request_data.get("ip_address")
            user_id = request_data.get("user_id")
            endpoint = request_data.get("endpoint")
            request_size = request_data.get("request_size", 0)
            geo_data = request_data.get("geo_data", {})
            
            if not ip_address:
                logger.warning("Request missing IP address")
                return None
            
            # Update traffic metrics
            self._update_traffic_metrics(ip_address, user_id, endpoint, current_time, request_size)
            
            # Run detection algorithms
            alerts = []
            
            # Rate limiting checks
            rate_alert = self._check_rate_limiting(ip_address, user_id, endpoint, current_time)
            if rate_alert:
                alerts.append(rate_alert)
            
            # DDoS pattern detection
            ddos_alert = self._detect_ddos_patterns(ip_address, current_time)
            if ddos_alert:
                alerts.append(ddos_alert)
            
            # Packet flood detection
            flood_alert = self._detect_packet_floods(ip_address, request_size, current_time)
            if flood_alert:
                alerts.append(flood_alert)
            
            # Geographic clustering analysis
            geo_alert = self._analyze_geographic_clustering(ip_address, geo_data, current_time)
            if geo_alert:
                alerts.append(geo_alert)
            
            # Return highest severity alert
            if alerts:
                highest_alert = max(alerts, key=lambda x: self._get_severity_level(x.severity))
                # Broadcast alert via WebSocket
                self._broadcast_air_wall_alert(highest_alert)
                return highest_alert
            
            # Periodic cleanup
            self._periodic_cleanup(current_time)
            
            return None
            
        except Exception as e:
            logger.error(f"Error analyzing request in Air Wall: {str(e)}")
            return None
    
    def _update_traffic_metrics(self, ip_address: str, user_id: Optional[str], 
                               endpoint: str, timestamp: float, request_size: int):
        """Update traffic metrics for all tracking dimensions."""
        # IP-based tracking
        ip_metrics = self.ip_traffic[ip_address]
        ip_metrics.request_count += 1
        ip_metrics.total_bytes += request_size
        ip_metrics.unique_endpoints.add(endpoint)
        
        if ip_metrics.first_request == 0:
            ip_metrics.first_request = timestamp
        ip_metrics.last_request = timestamp
        ip_metrics.request_times.append(timestamp)
        
        # User-based tracking (if authenticated)
        if user_id:
            user_metrics = self.user_traffic[user_id]
            user_metrics.request_count += 1
            user_metrics.total_bytes += request_size
            user_metrics.unique_endpoints.add(endpoint)
            
            if user_metrics.first_request == 0:
                user_metrics.first_request = timestamp
            user_metrics.last_request = timestamp
            user_metrics.request_times.append(timestamp)
        
        # Endpoint-based tracking
        endpoint_metrics = self.endpoint_traffic[endpoint]
        endpoint_metrics.request_count += 1
        endpoint_metrics.total_bytes += request_size
        
        if endpoint_metrics.first_request == 0:
            endpoint_metrics.first_request = timestamp
        endpoint_metrics.last_request = timestamp
        endpoint_metrics.request_times.append(timestamp)
    
    def _check_rate_limiting(self, ip_address: str, user_id: Optional[str], 
                            endpoint: str, current_time: float) -> Optional[AirWallAlert]:
        """Check if request violates rate limiting thresholds."""
        # IP-based rate limiting
        ip_metrics = self.ip_traffic[ip_address]
        requests_last_minute = self._count_requests_in_window(ip_metrics.request_times, current_time, 60)
        requests_last_hour = self._count_requests_in_window(ip_metrics.request_times, current_time, 3600)
        
        if requests_last_minute > self.config["max_requests_per_minute"]:
            return AirWallAlert(
                alert_type="rate_limit_exceeded",
                severity="medium",
                identifier=ip_address,
                timestamp=datetime.fromtimestamp(current_time),
                details={
                    "requests_last_minute": requests_last_minute,
                    "limit": self.config["max_requests_per_minute"],
                    "endpoint": endpoint
                },
                mitigation_action="temporary_block"
            )
        
        if requests_last_hour > self.config["max_requests_per_hour"]:
            return AirWallAlert(
                alert_type="rate_limit_exceeded",
                severity="high",
                identifier=ip_address,
                timestamp=datetime.fromtimestamp(current_time),
                details={
                    "requests_last_hour": requests_last_hour,
                    "limit": self.config["max_requests_per_hour"],
                    "endpoint": endpoint
                },
                mitigation_action="extended_block"
            )
        
        # User-based rate limiting (if authenticated)
        if user_id:
            user_metrics = self.user_traffic[user_id]
            user_requests_last_minute = self._count_requests_in_window(user_metrics.request_times, current_time, 60)
            
            if user_requests_last_minute > self.config["max_requests_per_minute"]:
                return AirWallAlert(
                    alert_type="user_rate_limit_exceeded",
                    severity="medium",
                    identifier=user_id,
                    timestamp=datetime.fromtimestamp(current_time),
                    details={
                        "requests_last_minute": user_requests_last_minute,
                        "limit": self.config["max_requests_per_minute"],
                        "endpoint": endpoint,
                        "ip_address": ip_address
                    },
                    mitigation_action="user_throttling"
                )
        
        return None
    
    def _detect_ddos_patterns(self, ip_address: str, current_time: float) -> Optional[AirWallAlert]:
        """Detect DDoS attack patterns."""
        ip_metrics = self.ip_traffic[ip_address]
        
        # Burst detection (requests in 1 second)
        requests_last_second = self._count_requests_in_window(ip_metrics.request_times, current_time, 1)
        
        if requests_last_second > self.config["ddos_burst_threshold"]:
            return AirWallAlert(
                alert_type="ddos_burst_detected",
                severity="critical",
                identifier=ip_address,
                timestamp=datetime.fromtimestamp(current_time),
                details={
                    "requests_last_second": requests_last_second,
                    "threshold": self.config["ddos_burst_threshold"],
                    "pattern": "burst_attack"
                },
                mitigation_action="immediate_block"
            )
        
        # Sustained attack detection (requests in 1 minute)
        requests_last_minute = self._count_requests_in_window(ip_metrics.request_times, current_time, 60)
        
        if requests_last_minute > self.config["ddos_sustained_threshold"]:
            return AirWallAlert(
                alert_type="ddos_sustained_detected",
                severity="high",
                identifier=ip_address,
                timestamp=datetime.fromtimestamp(current_time),
                details={
                    "requests_last_minute": requests_last_minute,
                    "threshold": self.config["ddos_sustained_threshold"],
                    "pattern": "sustained_attack"
                },
                mitigation_action="extended_block"
            )
        
        return None
    
    def _detect_packet_floods(self, ip_address: str, request_size: int, 
                             current_time: float) -> Optional[AirWallAlert]:
        """Detect packet flood attacks."""
        # Large packet detection
        if request_size > self.config["max_packet_size"]:
            return AirWallAlert(
                alert_type="large_packet_detected",
                severity="medium",
                identifier=ip_address,
                timestamp=datetime.fromtimestamp(current_time),
                details={
                    "packet_size": request_size,
                    "max_allowed": self.config["max_packet_size"],
                    "pattern": "packet_flood"
                },
                mitigation_action="packet_size_limit"
            )
        
        # Multiple large packets from same IP
        ip_metrics = self.ip_traffic[ip_address]
        large_packets_last_minute = sum(
            1 for req_time in ip_metrics.request_times
            if current_time - req_time <= 60 and req_time > current_time - 60
        )
        
        if large_packets_last_minute > 5:  # More than 5 large packets per minute
            return AirWallAlert(
                alert_type="packet_flood_detected",
                severity="high",
                identifier=ip_address,
                timestamp=datetime.fromtimestamp(current_time),
                details={
                    "large_packets_last_minute": large_packets_last_minute,
                    "pattern": "packet_flood"
                },
                mitigation_action="connection_limit"
            )
        
        return None
    
    def _analyze_geographic_clustering(self, ip_address: str, geo_data: Dict, 
                                     current_time: float) -> Optional[AirWallAlert]:
        """Analyze geographic clustering of requests."""
        if not self.config["enable_geo_tracking"] or not geo_data:
            return None
        
        # This is a simplified implementation
        # In production, you would track requests by geographic region
        # and detect unusual clustering patterns
        
        country = geo_data.get("country")
        region = geo_data.get("region")
        
        if country and region:
            geo_key = f"{country}:{region}"
            
            # Check for geographic clustering
            # This would require more sophisticated tracking
            # For now, we'll just log the geographic data
            logger.debug(f"Geographic data for {ip_address}: {geo_key}")
        
        return None
    
    def _count_requests_in_window(self, request_times: deque, current_time: float, 
                                 window_seconds: int) -> int:
        """Count requests within a time window."""
        cutoff_time = current_time - window_seconds
        return sum(1 for req_time in request_times if req_time > cutoff_time)
    
    def _get_severity_level(self, severity: str) -> int:
        """Get numeric severity level for comparison."""
        severity_levels = {
            "low": 1,
            "medium": 2,
            "high": 3,
            "critical": 4
        }
        return severity_levels.get(severity, 0)
    
    def _periodic_cleanup(self, current_time: float):
        """Periodically clean up old traffic data."""
        if current_time - self.last_cleanup < self.cleanup_interval:
            return
        
        cutoff_time = current_time - self.config["max_storage_duration"]
        
        # Clean up IP traffic
        expired_ips = [ip for ip, metrics in self.ip_traffic.items() 
                      if metrics.last_request < cutoff_time]
        for ip in expired_ips:
            del self.ip_traffic[ip]
        
        # Clean up user traffic
        expired_users = [user_id for user_id, metrics in self.user_traffic.items() 
                        if metrics.last_request < cutoff_time]
        for user_id in expired_users:
            del self.user_traffic[user_id]
        
        # Clean up endpoint traffic
        expired_endpoints = [endpoint for endpoint, metrics in self.endpoint_traffic.items() 
                           if metrics.last_request < cutoff_time]
        for endpoint in expired_endpoints:
            del self.endpoint_traffic[endpoint]
        
        self.last_cleanup = current_time
        logger.debug(f"Cleaned up {len(expired_ips)} IPs, {len(expired_users)} users, {len(expired_endpoints)} endpoints")
    
    def get_traffic_summary(self) -> Dict:
        """Get summary of current traffic patterns."""
        return {
            "active_ips": len(self.ip_traffic),
            "active_users": len(self.user_traffic),
            "active_endpoints": len(self.endpoint_traffic),
            "total_alerts": len(self.alerts),
            "last_cleanup": self.last_cleanup,
            "config": self.config
        }
    
    def reset_traffic_data(self):
        """Reset all traffic data (useful for testing)."""
        self.ip_traffic.clear()
        self.user_traffic.clear()
        self.endpoint_traffic.clear()
        self.alerts.clear()
        self.last_cleanup = time.time()
        logger.info("Air Wall traffic data reset")
    
    def _broadcast_air_wall_alert(self, alert: AirWallAlert):
        """
        Broadcast Air Wall alert via WebSocket to connected clients.
        
        This method integrates with the real-time alert system to provide
        instant notification of network threats to security officers.
        
        Args:
            alert: AirWallAlert object to broadcast
        """
        try:
            # Import here to avoid circular imports
            from realtime.alert_manager import broadcast_alert
            
            # Prepare alert data for WebSocket broadcasting
            alert_data = {
                "wall_name": "Air Wall",
                "threat_level": alert.severity.lower(),
                "details": {
                    "alert_type": alert.alert_type,
                    "identifier": alert.identifier,
                    "endpoint": alert.details.get("endpoint", "unknown"),
                    "requests_count": alert.details.get("requests_last_minute", alert.details.get("requests_last_hour", 0)),
                    "mitigation_action": alert.mitigation_action,
                    "timestamp": alert.timestamp.isoformat() if alert.timestamp else None
                },
                "source_wall": "air_wall",
                "identifier": alert.identifier,
                "alert_type": alert.alert_type,
                "severity": alert.severity,
                "mitigation_action": alert.mitigation_action
            }
            
            # Broadcast alert asynchronously
            import asyncio
            try:
                loop = asyncio.get_event_loop()
                if loop.is_running():
                    # Create task for broadcasting
                    asyncio.create_task(broadcast_alert(alert_data))
                else:
                    # Run in new event loop if needed
                    asyncio.run(broadcast_alert(alert_data))
            except RuntimeError:
                # Fallback if no event loop is available
                logger.warning("No event loop available for alert broadcasting")
                
        except ImportError:
            logger.warning("Real-time alert manager not available")
        except Exception as e:
            logger.error(f"Error broadcasting Air Wall alert: {e}")
