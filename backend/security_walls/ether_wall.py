"""
Ether Wall - Advanced Anti-Cheat and Anti-Hacking Protection

This module provides sophisticated protection against:
- Game cheating and exploits
- Memory injection attacks
- Client modification detection
- Server authoritative validation
- Unusual game behavior patterns
- Bot and automation detection
- Speed hacking and teleportation
- Resource manipulation

The Ether Wall operates at the game logic layer,
ensuring fair play and preventing sophisticated attacks.
"""

import time
import logging
import hashlib
import json
import math
from typing import Dict, List, Optional, Set, Any, Tuple
from dataclasses import dataclass
from datetime import datetime, timedelta
from enum import Enum
import random
from collections import defaultdict

logger = logging.getLogger(__name__)

class GameActionType(Enum):
    """Types of game actions."""
    MOVE = "move"
    ATTACK = "attack"
    USE_ITEM = "use_item"
    CRAFT = "craft"
    TRADE = "trade"
    CHAT = "chat"
    LOGIN = "login"
    LOGOUT = "logout"
    INTERACT = "interact"

class CheatType(Enum):
    """Types of detected cheating."""
    SPEED_HACK = "speed_hack"
    TELEPORT_HACK = "teleport_hack"
    AIMBOT = "aimbot"
    WALLHACK = "wallhack"
    RESOURCE_HACK = "resource_hack"
    BOT_ACTIVITY = "bot_activity"
    CLIENT_MODIFICATION = "client_modification"
    MEMORY_INJECTION = "memory_injection"

@dataclass
class GameAction:
    """Record of a game action."""
    timestamp: float
    user_id: str
    action_type: GameActionType
    action_data: Dict
    client_hash: str
    session_id: str
    ip_address: str
    game_state: Dict
    validation_result: Optional[str] = None

@dataclass
class PlayerProfile:
    """Player behavior profile for anti-cheat analysis."""
    user_id: str
    first_seen: float
    last_seen: float
    total_actions: int
    actions_by_type: Dict[str, int]
    average_response_time: float
    suspicious_actions: int
    cheat_score: float
    is_flagged: bool
    last_validation: float
    flag_reason: Optional[str] = None

@dataclass
class EtherWallAlert:
    """Alert generated by Ether Wall detection."""
    alert_type: str
    severity: str  # low, medium, high, critical
    identifier: str  # user_id or session_id
    timestamp: datetime
    details: Dict
    cheat_type: CheatType
    mitigation_action: str
    confidence_score: float

class EtherWall:
    """
    Ether Wall implementation for advanced anti-cheat and anti-hacking protection.
    
    Features:
    - Server authoritative validation
    - Behavior pattern analysis
    - Physics validation
    - Client integrity checks
    - Bot detection
    - Memory injection detection
    - Adaptive cheat detection
    """
    
    def __init__(self, config: Optional[Dict] = None):
        """
        Initialize Ether Wall with configuration.
        
        Args:
            config: Configuration dictionary with thresholds and settings
        """
        self.config = config or self._get_default_config()
        
        # Game action tracking
        self.game_actions: List[GameAction] = []
        self.player_profiles: Dict[str, PlayerProfile] = {}
        
        # Session tracking
        self.active_sessions: Dict[str, Dict] = defaultdict(dict) # Changed to defaultdict for simplicity
        self.session_actions: Dict[str, List[GameAction]] = defaultdict(list)
        
        # Client integrity tracking
        self.client_hashes: Dict[str, Dict] = {}
        self.suspicious_clients: Set[str] = set()
        
        # Game state validation
        self.game_rules = self._initialize_game_rules()
        self.physics_constraints = self._initialize_physics_constraints()
        
        # Alert storage
        self.alerts: List[EtherWallAlert] = []
        
        # Cleanup timer
        self.last_cleanup = time.time()
        self.cleanup_interval = 300  # 5 minutes
        
        logger.info("Ether Wall initialized with configuration: %s", self.config)
    
    def _get_default_config(self) -> Dict:
        """Get default configuration for Ether Wall."""
        return {
            # Action validation thresholds
            "max_actions_per_second": 10,
            "max_actions_per_minute": 300,
            "max_actions_per_hour": 10000,
            
            # Cheat detection thresholds
            "speed_hack_threshold": 1.5,  # 1.5x normal speed
            "teleport_distance_threshold": 100.0,  # units
            "teleport_time_threshold": 1.0,  # seconds
            "aimbot_accuracy_threshold": 0.95,  # 95% accuracy
            "wallhack_detection_enabled": True,
            
            # Bot detection
            "bot_response_time_threshold": 0.1,  # 100ms
            "bot_pattern_threshold": 0.8,  # 80% pattern similarity
            "bot_activity_threshold": 0.9,  # 90% automated behavior
            
            # Client integrity
            "client_hash_validation": True,
            "client_modification_threshold": 0.1,  # 10% modification
            "memory_injection_threshold": 0.05,  # 5% injection
            
            # Physics validation
            "physics_validation_enabled": True,
            "collision_detection": True,
            "gravity_validation": True,
            "momentum_validation": True,
            
            # Behavior analysis
            "behavior_analysis_enabled": True,
            "pattern_recognition": True,
            "anomaly_detection": True,
            "machine_learning_enabled": False,  # Future enhancement
            
            # Mitigation actions
            "auto_kick_enabled": True,
            "progressive_penalties": True,
            "appeal_system_enabled": True,
            
            # Cleanup settings
            "cleanup_interval": 300,  # 5 minutes
            "max_storage_duration": 86400,  # 24 hours
            "max_actions_stored": 50000,
        }
    
    def _initialize_game_rules(self) -> Dict:
        """Initialize game rules and constraints."""
        return {
            "max_player_speed": 10.0,  # units per second
            "max_jump_height": 5.0,  # units
            "max_inventory_size": 100,
            "max_crafting_time": 30.0,  # seconds
            "max_trade_distance": 10.0,  # units
            "max_chat_length": 200,  # characters
            "min_action_interval": 0.1,  # seconds
            "max_concurrent_actions": 3,
        }
    
    def _initialize_physics_constraints(self) -> Dict:
        """Initialize physics validation constraints."""
        return {
            "gravity": 9.81,  # units per second squared
            "friction": 0.8,  # coefficient
            "air_resistance": 0.1,  # coefficient
            "max_velocity": 50.0,  # units per second
            "max_acceleration": 20.0,  # units per second squared
            "collision_bounds": {
                "player": {"width": 1.0, "height": 2.0, "depth": 1.0},
                "terrain": {"width": 1000.0, "height": 1000.0, "depth": 1000.0}
            }
        }
    
    def validate_game_action(self, action_data: Dict) -> Tuple[bool, Optional[EtherWallAlert]]:
        """
        Validate a game action for cheating and exploits.
        
        Args:
            action_data: Dictionary containing game action information
                - user_id: User performing the action
                - action_type: Type of game action
                - action_data: Action-specific data
                - client_hash: Hash of client state
                - session_id: Game session ID
                - ip_address: Client IP address
                - game_state: Current game state
                - timestamp: Action timestamp
        
        Returns:
            Tuple of (is_valid, alert_if_detected)
        """
        try:
            current_time = time.time()
            
            # Extract action information
            user_id = action_data.get("user_id")
            action_type = GameActionType(action_data.get("action_type"))
            action_data_dict = action_data.get("action_data", {})
            client_hash = action_data.get("client_hash")
            session_id = action_data.get("session_id")
            ip_address = action_data.get("ip_address")
            game_state = action_data.get("game_state", {})
            timestamp = action_data.get("timestamp", current_time)
            
            if not all([user_id, action_type, client_hash, session_id]):
                logger.warning("Game action missing required fields")
                return False, None
            
            # Create action record
            action = GameAction(
                timestamp=timestamp,
                user_id=user_id,
                action_type=action_type,
                action_data=action_data_dict,
                client_hash=client_hash,
                session_id=session_id,
                ip_address=ip_address,
                game_state=game_state
            )
            
            # Store the action
            self.game_actions.append(action)
            self.session_actions[session_id].append(action)
            
            # Limit stored actions
            if len(self.game_actions) > self.config["max_actions_stored"]:
                self.game_actions = self.game_actions[-self.config["max_actions_stored"]:]
            
            # Update player profile
            self._update_player_profile(action, current_time)
            
            # Update session tracking
            self._update_session_tracking(action, current_time)
            
            # Run comprehensive validation
            validation_result = self._comprehensive_validation(action, current_time)
            
            if validation_result:
                return False, validation_result
            
            # Mark action as valid
            action.validation_result = "valid"
            
            # Periodic cleanup
            self._periodic_cleanup(current_time)
            
            return True, None
            
        except Exception as e:
            logger.error(f"Error validating game action in Ether Wall: {str(e)}")
            return False, None
    
    def _update_player_profile(self, action: GameAction, current_time: float):
        """Update player behavior profile."""
        if action.user_id not in self.player_profiles:
            self.player_profiles[action.user_id] = PlayerProfile(
                user_id=action.user_id,
                first_seen=current_time,
                last_seen=current_time,
                total_actions=0,
                actions_by_type=defaultdict(int),
                average_response_time=0.0,
                suspicious_actions=0,
                cheat_score=0.0,
                is_flagged=False,
                last_validation=current_time
            )
        
        profile = self.player_profiles[action.user_id]
        profile.last_seen = current_time
        profile.total_actions += 1
        profile.actions_by_type[action.action_type.value] += 1
        
        # Update response time (simplified calculation)
        if profile.total_actions > 1:
            profile.average_response_time = (
                (profile.average_response_time * (profile.total_actions - 1) + 0.1) / 
                profile.total_actions
            )
    
    def _update_session_tracking(self, action: GameAction, current_time: float):
        """Update session tracking information."""
        if action.session_id not in self.active_sessions:
            self.active_sessions[action.session_id] = {
                "user_id": action.user_id,
                "start_time": current_time,
                "last_action": current_time,
                "total_actions": 0,
                "ip_address": action.ip_address,
                "client_hash": action.client_hash
            }
        
        session = self.active_sessions[action.session_id]
        session["last_action"] = current_time
        session["total_actions"] += 1
    
    def _comprehensive_validation(self, action: GameAction, current_time: float) -> Optional[EtherWallAlert]:
        """Run comprehensive validation checks."""
        alerts = []
        
        # Rate limiting checks
        rate_alert = self._check_action_rate_limits(action, current_time)
        if rate_alert:
            alerts.append(rate_alert)
        
        # Physics validation
        if self.config["physics_validation_enabled"]:
            physics_alert = self._validate_physics(action, current_time)
            if physics_alert:
                alerts.append(physics_alert)
        
        # Client integrity checks
        if self.config["client_hash_validation"]:
            integrity_alert = self._check_client_integrity(action, current_time)
            if integrity_alert:
                alerts.append(integrity_alert)
        
        # Behavior pattern analysis
        if self.config["behavior_analysis_enabled"]:
            behavior_alert = self._analyze_behavior_patterns(action, current_time)
            if behavior_alert:
                alerts.append(behavior_alert)
        
        # Bot detection
        bot_alert = self._detect_bot_activity(action, current_time)
        if bot_alert:
            alerts.append(bot_alert)
        
        # Game rule validation
        rule_alert = self._validate_game_rules(action, current_time)
        if rule_alert:
            alerts.append(rule_alert)
        
        # Return highest severity alert
        if alerts:
            highest_alert = max(alerts, key=lambda x: self._get_severity_level(x.severity))
            # Broadcast alert via WebSocket
            self._broadcast_ether_wall_alert(highest_alert)
            return highest_alert
        
        return None
    
    def _check_action_rate_limits(self, action: GameAction, current_time: float) -> Optional[EtherWallAlert]:
        """Check if action violates rate limiting thresholds."""
        # Count actions in time windows
        actions_last_second = self._count_actions_in_window(action.user_id, current_time, 1)
        actions_last_minute = self._count_actions_in_window(action.user_id, current_time, 60)
        actions_last_hour = self._count_actions_in_window(action.user_id, current_time, 3600)
        
        if actions_last_second > self.config["max_actions_per_second"]:
            return EtherWallAlert(
                alert_type="action_rate_limit_exceeded",
                severity="high",
                identifier=action.user_id,
                timestamp=datetime.fromtimestamp(current_time),
                details={
                    "actions_last_second": actions_last_second,
                    "limit": self.config["max_actions_per_second"],
                    "action_type": action.action_type.value
                },
                cheat_type=CheatType.SPEED_HACK,
                mitigation_action="temporary_ban",
                confidence_score=0.8
            )
        
        if actions_last_minute > self.config["max_actions_per_minute"]:
            return EtherWallAlert(
                alert_type="action_rate_limit_exceeded",
                severity="medium",
                identifier=action.user_id,
                timestamp=datetime.fromtimestamp(current_time),
                details={
                    "actions_last_minute": actions_last_minute,
                    "limit": self.config["max_actions_per_minute"],
                    "action_type": action.action_type.value
                },
                cheat_type=CheatType.SPEED_HACK,
                mitigation_action="throttling",
                confidence_score=0.7
            )
        
        return None
    
    def _validate_physics(self, action: GameAction, current_time: float) -> Optional[EtherWallAlert]:
        """Validate physics constraints."""
        if action.action_type != GameActionType.MOVE:
            return None
        
        # Extract movement data
        movement_data = action.action_data.get("movement", {})
        current_position = movement_data.get("current_position", {})
        new_position = movement_data.get("new_position", {})
        movement_time = movement_data.get("movement_time", 1.0)
        
        if not all([current_position, new_position]):
            return None
        
        # Calculate distance and speed
        distance = self._calculate_distance(current_position, new_position)
        speed = distance / movement_time if movement_time > 0 else 0
        
        # Check for speed hacking
        if speed > self.game_rules["max_player_speed"] * self.config["speed_hack_threshold"]:
            return EtherWallAlert(
                alert_type="speed_hack_detected",
                severity="high",
                identifier=action.user_id,
                timestamp=datetime.fromtimestamp(current_time),
                details={
                    "detected_speed": speed,
                    "max_allowed_speed": self.game_rules["max_player_speed"],
                    "threshold": self.config["speed_hack_threshold"],
                    "distance": distance,
                    "movement_time": movement_time
                },
                cheat_type=CheatType.SPEED_HACK,
                mitigation_action="movement_restriction",
                confidence_score=0.9
            )
        
        # Check for teleportation
        if distance > self.config["teleport_distance_threshold"] and movement_time < self.config["teleport_time_threshold"]:
            return EtherWallAlert(
                alert_type="teleport_hack_detected",
                severity="critical",
                identifier=action.user_id,
                timestamp=datetime.fromtimestamp(current_time),
                details={
                    "distance": distance,
                    "movement_time": movement_time,
                    "distance_threshold": self.config["teleport_distance_threshold"],
                    "time_threshold": self.config["teleport_time_threshold"]
                },
                cheat_type=CheatType.TELEPORT_HACK,
                mitigation_action="immediate_ban",
                confidence_score=0.95
            )
        
        return None
    
    def _check_client_integrity(self, action: GameAction, current_time: float) -> Optional[EtherWallAlert]:
        """Check client integrity and detect modifications."""
        client_hash = action.client_hash
        
        if client_hash not in self.client_hashes:
            self.client_hashes[client_hash] = {
                "first_seen": current_time,
                "last_seen": current_time,
                "users": set(),
                "modification_count": 0,
                "suspicious_behavior": 0
            }
        
        client_info = self.client_hashes[client_hash]
        client_info["last_seen"] = current_time
        client_info["users"].add(action.user_id)
        
        # Check for client hash changes (potential modification)
        user_sessions = [s for s in self.active_sessions.values() if s["user_id"] == action.user_id]
        if len(user_sessions) > 1:
            # User has multiple sessions with different client hashes
            client_info["modification_count"] += 1
            
            if client_info["modification_count"] > 3:
                return EtherWallAlert(
                    alert_type="client_modification_detected",
                    severity="high",
                    identifier=action.user_id,
                    timestamp=datetime.fromtimestamp(current_time),
                    details={
                        "client_hash": client_hash,
                        "modification_count": client_info["modification_count"],
                        "session_count": len(user_sessions)
                    },
                    cheat_type=CheatType.CLIENT_MODIFICATION,
                    mitigation_action="client_verification",
                    confidence_score=0.8
                )
        
        # Check for suspicious client behavior
        if client_hash in self.suspicious_clients:
            client_info["suspicious_behavior"] += 1
            
            if client_info["suspicious_behavior"] > 5:
                return EtherWallAlert(
                    alert_type="suspicious_client_behavior",
                    severity="medium",
                    identifier=action.user_id,
                    timestamp=datetime.fromtimestamp(current_time),
                    details={
                        "client_hash": client_hash,
                        "suspicious_behavior_count": client_info["suspicious_behavior"]
                    },
                    cheat_type=CheatType.CLIENT_MODIFICATION,
                    mitigation_action="client_investigation",
                    confidence_score=0.7
                )
        
        return None
    
    def _analyze_behavior_patterns(self, action: GameAction, current_time: float) -> Optional[EtherWallAlert]:
        """Analyze behavior patterns for anomalies."""
        profile = self.player_profiles.get(action.user_id)
        if not profile or profile.total_actions < 10:
            return None  # Need more data for pattern analysis
        
        # Check for unusual action patterns
        action_type_count = profile.actions_by_type.get(action.action_type.value, 0)
        total_actions = profile.total_actions
        
        if total_actions > 0:
            action_type_ratio = action_type_count / total_actions
            
            # Detect unusual action type distribution
            if action_type_ratio > 0.8:  # 80% of actions are the same type
                return EtherWallAlert(
                    alert_type="unusual_action_pattern",
                    severity="low",
                    identifier=action.user_id,
                    timestamp=datetime.fromtimestamp(current_time),
                    details={
                        "action_type": action.action_type.value,
                        "action_type_ratio": action_type_ratio,
                        "total_actions": total_actions
                    },
                    cheat_type=CheatType.BOT_ACTIVITY,
                    mitigation_action="behavior_monitoring",
                    confidence_score=0.6
                )
        
        # Check for suspicious response times
        if profile.average_response_time < self.config["bot_response_time_threshold"]:
            return EtherWallAlert(
                alert_type="suspicious_response_time",
                severity="medium",
                identifier=action.user_id,
                timestamp=datetime.fromtimestamp(current_time),
                details={
                    "average_response_time": profile.average_response_time,
                    "threshold": self.config["bot_response_time_threshold"]
                },
                cheat_type=CheatType.BOT_ACTIVITY,
                mitigation_action="response_time_monitoring",
                confidence_score=0.7
            )
        
        return None
    
    def _detect_bot_activity(self, action: GameAction, current_time: float) -> Optional[EtherWallAlert]:
        """Detect bot and automation activity."""
        # Check for repetitive patterns
        recent_actions = [
            a for a in self.game_actions
            if a.user_id == action.user_id and current_time - a.timestamp <= 300  # 5 minutes
        ]
        
        if len(recent_actions) > 10:
            # Analyze pattern similarity
            pattern_similarity = self._calculate_pattern_similarity(recent_actions)
            
            if pattern_similarity > self.config["bot_pattern_threshold"]:
                return EtherWallAlert(
                    alert_type="bot_activity_detected",
                    severity="medium",
                    identifier=action.user_id,
                    timestamp=datetime.fromtimestamp(current_time),
                    details={
                        "pattern_similarity": pattern_similarity,
                        "threshold": self.config["bot_pattern_threshold"],
                        "recent_actions": len(recent_actions)
                    },
                    cheat_type=CheatType.BOT_ACTIVITY,
                    mitigation_action="bot_verification",
                    confidence_score=0.8
                )
        
        return None
    
    def _validate_game_rules(self, action: GameAction, current_time: float) -> Optional[EtherWallAlert]:
        """Validate game rules and constraints."""
        # Check action-specific rules
        if action.action_type == GameActionType.CHAT:
            chat_message = action.action_data.get("message", "")
            if len(chat_message) > self.game_rules["max_chat_length"]:
                return EtherWallAlert(
                    alert_type="game_rule_violation",
                    severity="low",
                    identifier=action.user_id,
                    timestamp=datetime.fromtimestamp(current_time),
                    details={
                        "rule": "max_chat_length",
                        "violation": len(chat_message),
                        "limit": self.game_rules["max_chat_length"]
                    },
                    cheat_type=CheatType.CLIENT_MODIFICATION,
                    mitigation_action="chat_restriction",
                    confidence_score=0.9
                )
        
        # Check for concurrent action violations
        concurrent_actions = self._count_concurrent_actions(action.user_id, current_time)
        if concurrent_actions > self.game_rules["max_concurrent_actions"]:
            return EtherWallAlert(
                alert_type="concurrent_action_violation",
                severity="medium",
                identifier=action.user_id,
                timestamp=datetime.fromtimestamp(current_time),
                details={
                    "concurrent_actions": concurrent_actions,
                    "limit": self.game_rules["max_concurrent_actions"]
                },
                cheat_type=CheatType.SPEED_HACK,
                mitigation_action="action_throttling",
                confidence_score=0.8
            )
        
        return None
    
    def _calculate_distance(self, pos1: Dict, pos2: Dict) -> float:
        """Calculate Euclidean distance between two positions."""
        x1, y1, z1 = pos1.get("x", 0), pos1.get("y", 0), pos1.get("z", 0)
        x2, y2, z2 = pos2.get("x", 0), pos2.get("y", 0), pos2.get("z", 0)
        
        return math.sqrt((x2 - x1)**2 + (y2 - y1)**2 + (z2 - z1)**2)
    
    def _calculate_pattern_similarity(self, actions: List[GameAction]) -> float:
        """Calculate similarity between action patterns (simplified)."""
        if len(actions) < 2:
            return 0.0
        
        # Simple pattern similarity based on action types
        action_types = [a.action_type.value for a in actions]
        unique_types = len(set(action_types))
        total_actions = len(actions)
        
        # Lower diversity = higher similarity (more bot-like)
        return 1.0 - (unique_types / total_actions)
    
    def _count_actions_in_window(self, user_id: str, current_time: float, window_seconds: int) -> int:
        """Count actions by a user within a time window."""
        cutoff_time = current_time - window_seconds
        return sum(1 for action in self.game_actions 
                  if action.user_id == user_id and action.timestamp > cutoff_time)
    
    def _count_concurrent_actions(self, user_id: str, current_time: float) -> int:
        """Count concurrent actions by a user."""
        # Count actions within a small time window (e.g., 0.1 seconds)
        window = 0.1
        cutoff_time = current_time - window
        return sum(1 for action in self.game_actions 
                  if action.user_id == user_id and action.timestamp > cutoff_time)
    
    def _get_severity_level(self, severity: str) -> int:
        """Get numeric severity level for comparison."""
        severity_levels = {
            "low": 1,
            "medium": 2,
            "high": 3,
            "critical": 4
        }
        return severity_levels.get(severity, 0)
    
    def _periodic_cleanup(self, current_time: float):
        """Periodically clean up old data."""
        if current_time - self.last_cleanup < self.cleanup_interval:
            return
        
        cutoff_time = current_time - self.config["max_storage_duration"]
        
        # Clean up old actions
        self.game_actions = [
            action for action in self.game_actions
            if action.timestamp > cutoff_time
        ]
        
        # Clean up old sessions
        expired_sessions = [
            session_id for session_id, session in self.active_sessions.items()
            if current_time - session["last_action"] > 3600  # 1 hour
        ]
        for session_id in expired_sessions:
            del self.active_sessions[session_id]
            if session_id in self.session_actions:
                del self.session_actions[session_id]
        
        # Clean up old player profiles
        expired_profiles = [
            user_id for user_id, profile in self.player_profiles.items()
            if current_time - profile.last_seen > self.config["max_storage_duration"]
        ]
        for user_id in expired_profiles:
            del self.player_profiles[user_id]
        
        self.last_cleanup = current_time
        logger.debug(f"Ether Wall cleanup completed")
    
    def flag_player(self, user_id: str, reason: str, confidence: float = 0.8):
        """Flag a player for suspicious behavior."""
        if user_id in self.player_profiles:
            profile = self.player_profiles[user_id]
            profile.is_flagged = True
            profile.flag_reason = reason
            profile.cheat_score = min(profile.cheat_score + confidence * 10, 100.0)
            
            logger.info(f"Player {user_id} flagged: {reason} (confidence: {confidence})")
    
    def get_anti_cheat_summary(self) -> Dict:
        """Get summary of current anti-cheat status."""
        return {
            "total_actions": len(self.game_actions),
            "monitored_players": len(self.player_profiles),
            "active_sessions": len(self.active_sessions),
            "flagged_players": sum(1 for p in self.player_profiles.values() if p.is_flagged),
            "suspicious_clients": len(self.suspicious_clients),
            "total_alerts": len(self.alerts),
            "config": self.config
        }
    
    def reset_anti_cheat_data(self):
        """Reset all anti-cheat data (useful for testing)."""
        self.game_actions.clear()
        self.player_profiles.clear()
        self.active_sessions.clear()
        self.session_actions.clear()
        self.client_hashes.clear()
        self.suspicious_clients.clear()
        self.alerts.clear()
        self.last_cleanup = time.time()
        logger.info("Ether Wall anti-cheat data reset")
    
    def _broadcast_ether_wall_alert(self, alert: EtherWallAlert):
        """
        Broadcast Ether Wall alert via WebSocket to connected clients.
        
        This method integrates with the real-time alert system to provide
        instant notification of anti-cheat threats to security officers.
        
        Args:
            alert: EtherWallAlert object to broadcast
        """
        try:
            # Import here to avoid circular imports
            from realtime.alert_manager import broadcast_alert
            
            # Prepare alert data for WebSocket broadcasting
            alert_data = {
                "wall_name": "Ether Wall",
                "threat_level": alert.severity.lower(),
                "details": {
                    "alert_type": alert.alert_type,
                    "identifier": alert.identifier,
                    "cheat_type": alert.cheat_type.value if alert.cheat_type else "unknown",
                    "confidence_score": alert.confidence_score,
                    "action_type": alert.details.get("action_type", "unknown"),
                    "mitigation_action": alert.mitigation_action,
                    "timestamp": alert.timestamp.isoformat() if alert.timestamp else None
                },
                "source_wall": "ether_wall",
                "identifier": alert.identifier,
                "alert_type": alert.alert_type,
                "severity": alert.severity,
                "mitigation_action": alert.mitigation_action
            }
            
            # Broadcast alert asynchronously
            import asyncio
            try:
                loop = asyncio.get_event_loop()
                if loop.is_running():
                    # Create task for broadcasting
                    asyncio.create_task(broadcast_alert(alert_data))
                else:
                    # Run in new event loop if needed
                    asyncio.run(broadcast_alert(alert_data))
            except RuntimeError:
                # Fallback if no event loop is available
                logger.warning("No event loop available for alert broadcasting")
                
        except ImportError:
            logger.warning("Real-time alert manager not available")
        except Exception as e:
            logger.error(f"Error broadcasting Ether Wall alert: {e}")
